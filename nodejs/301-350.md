# GraphQL and API Development (301-310)

### 301. How do you implement a GraphQL server in Node.js?
**Answer:**
- Use Apollo Server or Express with GraphQL
- Define schema and resolvers
- Handle authentication and authorization
- Implement error handling

```javascript
const { ApolloServer, gql } = require('apollo-server-express');
const express = require('express');

// Define schema
const typeDefs = gql`
  type User {
    id: ID!
    name: String!
    email: String!
    posts: [Post!]!
  }

  type Post {
    id: ID!
    title: String!
    content: String!
    author: User!
  }

  type Query {
    user(id: ID!): User
    users: [User!]!
    post(id: ID!): Post
    posts: [Post!]!
  }

  type Mutation {
    createUser(name: String!, email: String!): User!
    createPost(title: String!, content: String!, authorId: ID!): Post!
  }
`;

// Implement resolvers
const resolvers = {
  Query: {
    user: async (_, { id }, { dataSources }) => {
      return dataSources.users.getUser(id);
    },
    users: async (_, __, { dataSources }) => {
      return dataSources.users.getAllUsers();
    }
  },
  Mutation: {
    createUser: async (_, { name, email }, { dataSources }) => {
      return dataSources.users.createUser({ name, email });
    }
  },
  User: {
    posts: async (user, _, { dataSources }) => {
      return dataSources.posts.getPostsByUser(user.id);
    }
  }
};

// Create server
const server = new ApolloServer({
  typeDefs,
  resolvers,
  context: ({ req }) => ({
    dataSources: {
      users: new UserDataSource(),
      posts: new PostDataSource()
    },
    user: req.user
  })
});

const app = express();
server.applyMiddleware({ app });

app.listen(4000, () => {
  console.log(`Server running at http://localhost:4000${server.graphqlPath}`);
});
```

---

### 302. What is the difference between REST and GraphQL?
**Answer:**
- REST is resource-based, GraphQL is query-based
- REST has multiple endpoints, GraphQL has a single endpoint
- REST over-fetches or under-fetches data, GraphQL fetches exactly what's needed
- REST is more cacheable, GraphQL requires more complex caching

```javascript
// REST API Example
app.get('/api/users/:id', async (req, res) => {
  const user = await User.findById(req.params.id);
  res.json(user); // Returns all user fields
});

app.get('/api/users/:id/posts', async (req, res) => {
  const posts = await Post.find({ userId: req.params.id });
  res.json(posts); // Requires separate request for posts
});

// GraphQL Example
const typeDefs = gql`
  type User {
    id: ID!
    name: String!
    email: String!
    posts: [Post!]!
  }

  type Query {
    user(id: ID!): User
  }
`;

// Client can request exactly what they need
const query = gql`
  query {
    user(id: "123") {
      name
      posts {
        title
      }
    }
  }
`;
```

---

### 303. How do you handle GraphQL subscriptions in Node.js?
**Answer:**
- Use WebSocket for real-time updates
- Implement PubSub for event handling
- Handle subscription authentication
- Manage subscription lifecycle

```javascript
const { ApolloServer, PubSub } = require('apollo-server-express');
const { createServer } = require('http');

const pubsub = new PubSub();

const typeDefs = gql`
  type Message {
    id: ID!
    content: String!
    user: User!
  }

  type Subscription {
    messageAdded: Message!
    userTyping(userId: ID!): Boolean!
  }
`;

const resolvers = {
  Subscription: {
    messageAdded: {
      subscribe: () => pubsub.asyncIterator(['MESSAGE_ADDED'])
    },
    userTyping: {
      subscribe: (_, { userId }) => 
        pubsub.asyncIterator([`USER_TYPING_${userId}`])
    }
  }
};

const server = new ApolloServer({
  typeDefs,
  resolvers,
  subscriptions: {
    onConnect: (connectionParams) => {
      // Handle subscription authentication
      if (connectionParams.authToken) {
        return validateToken(connectionParams.authToken);
      }
      throw new Error('Missing auth token');
    }
  }
});

const app = express();
const httpServer = createServer(app);

server.installSubscriptionHandlers(httpServer);

// Publish events
async function sendMessage(message) {
  await pubsub.publish('MESSAGE_ADDED', {
    messageAdded: message
  });
}
```

---

### 304. What is the purpose of GraphQL resolvers?
**Answer:**
- Resolvers fetch data for each field
- Handle data transformation
- Implement business logic
- Manage data relationships

```javascript
const resolvers = {
  Query: {
    user: async (_, { id }, { dataSources }) => {
      // Fetch user data
      const user = await dataSources.users.getUser(id);
      if (!user) throw new Error('User not found');
      return user;
    }
  },
  User: {
    // Field-level resolver
    fullName: (user) => `${user.firstName} ${user.lastName}`,
    
    // Relationship resolver
    posts: async (user, _, { dataSources }) => {
      return dataSources.posts.getPostsByUser(user.id);
    },
    
    // Computed field resolver
    postCount: async (user, _, { dataSources }) => {
      const posts = await dataSources.posts.getPostsByUser(user.id);
      return posts.length;
    }
  },
  Mutation: {
    createUser: async (_, { input }, { dataSources }) => {
      // Validate input
      validateUserInput(input);
      
      // Create user
      const user = await dataSources.users.createUser(input);
      
      // Publish event
      pubsub.publish('USER_CREATED', { userCreated: user });
      
      return user;
    }
  }
};
```

---

### 305. How do you implement GraphQL authentication?
**Answer:**
- Use JWT for authentication
- Implement context for user info
- Handle authorization directives
- Secure sensitive operations

```javascript
const { AuthenticationError, ForbiddenError } = require('apollo-server-express');
const jwt = require('jsonwebtoken');

// Authentication directive
const authDirective = {
  auth: {
    async resolve(resolve, source, args, context, info) {
      if (!context.user) {
        throw new AuthenticationError('Not authenticated');
      }
      return resolve(source, args, context, info);
    }
  }
};

// Context middleware
const context = async ({ req }) => {
  const token = req.headers.authorization?.replace('Bearer ', '');
  
  if (token) {
    try {
      const user = jwt.verify(token, process.env.JWT_SECRET);
      return { user };
    } catch (error) {
      throw new AuthenticationError('Invalid token');
    }
  }
  
  return { user: null };
};

// Protected resolver
const resolvers = {
  Query: {
    me: async (_, __, { user }) => {
      if (!user) throw new AuthenticationError('Not authenticated');
      return user;
    }
  },
  Mutation: {
    updateUser: async (_, { input }, { user }) => {
      if (!user) throw new AuthenticationError('Not authenticated');
      if (user.id !== input.id) {
        throw new ForbiddenError('Not authorized');
      }
      return updateUser(input);
    }
  }
};
```

---

### 306. What is the purpose of GraphQL directives?
**Answer:**
- Modify schema execution
- Add custom behavior
- Implement field-level features
- Handle cross-cutting concerns

```javascript
const { SchemaDirectiveVisitor } = require('apollo-server-express');

// Custom directive for caching
class CacheDirective extends SchemaDirectiveVisitor {
  visitFieldDefinition(field) {
    const { ttl } = this.args;
    const { resolve } = field;
    
    field.resolve = async (source, args, context, info) => {
      const cacheKey = `${info.parentType.name}.${field.name}.${JSON.stringify(args)}`;
      
      // Check cache
      const cached = await context.cache.get(cacheKey);
      if (cached) return cached;
      
      // Resolve and cache
      const result = await resolve(source, args, context, info);
      await context.cache.set(cacheKey, result, ttl);
      
      return result;
    };
  }
}

// Usage in schema
const typeDefs = gql`
  directive @cache(ttl: Int!) on FIELD_DEFINITION

  type Query {
    user(id: ID!): User @cache(ttl: 60)
    posts: [Post!]! @cache(ttl: 30)
  }
`;

const schema = makeExecutableSchema({
  typeDefs,
  resolvers,
  schemaDirectives: {
    cache: CacheDirective
  }
});
```

---

### 307. How do you handle GraphQL caching?
**Answer:**
- Implement field-level caching
- Use DataLoader for batching
- Cache query results
- Handle cache invalidation

```javascript
const DataLoader = require('dataloader');
const Redis = require('ioredis');

class GraphQLCache {
  constructor() {
    this.redis = new Redis();
    this.loaders = new Map();
  }

  // Create DataLoader for batching
  getUserLoader() {
    if (!this.loaders.has('user')) {
      this.loaders.set('user', new DataLoader(async (ids) => {
        const users = await User.find({ _id: { $in: ids } });
        return ids.map(id => users.find(u => u.id === id));
      }));
    }
    return this.loaders.get('user');
  }

  // Cache query results
  async cacheQuery(query, variables, result) {
    const key = `query:${JSON.stringify({ query, variables })}`;
    await this.redis.set(key, JSON.stringify(result), 'EX', 3600);
  }

  // Get cached query
  async getCachedQuery(query, variables) {
    const key = `query:${JSON.stringify({ query, variables })}`;
    const cached = await this.redis.get(key);
    return cached ? JSON.parse(cached) : null;
  }

  // Invalidate cache
  async invalidateCache(pattern) {
    const keys = await this.redis.keys(pattern);
    if (keys.length) {
      await this.redis.del(keys);
    }
  }
}

// Usage in resolvers
const resolvers = {
  Query: {
    user: async (_, { id }, { cache }) => {
      const loader = cache.getUserLoader();
      return loader.load(id);
    }
  }
};
```

---

### 308. What is the purpose of GraphQL schema stitching?
**Answer:**
- Combine multiple GraphQL schemas
- Create a unified API
- Handle cross-service queries
- Manage schema relationships

```javascript
const { mergeSchemas } = require('@graphql-tools/schema');
const { introspectSchema } = require('@graphql-tools/wrap');
const { makeRemoteExecutableSchema } = require('@graphql-tools/remote');

async function createStitchedSchema() {
  // Introspect remote schemas
  const userSchema = await introspectSchema(
    makeRemoteExecutableSchema({
      schema: await fetchRemoteSchema('http://users-service/graphql'),
      fetcher: createFetcher('http://users-service/graphql')
    })
  );

  const postSchema = await introspectSchema(
    makeRemoteExecutableSchema({
      schema: await fetchRemoteSchema('http://posts-service/graphql'),
      fetcher: createFetcher('http://posts-service/graphql')
    })
  );

  // Merge schemas
  return mergeSchemas({
    schemas: [userSchema, postSchema],
    resolvers: {
      User: {
        posts: {
          fragment: 'fragment UserFragment on User { id }',
          resolve: async (user, args, context, info) => {
            return context.posts.getPostsByUser(user.id);
          }
        }
      }
    }
  });
}
```

---

### 309. How do you implement GraphQL error handling?
**Answer:**
- Use custom error types
- Handle validation errors
- Implement error formatting
- Provide error context

```javascript
const { ApolloError, UserInputError } = require('apollo-server-express');

class ValidationError extends ApolloError {
  constructor(message: string, field: string) {
    super(message, 'VALIDATION_ERROR');
    this.field = field;
  }
}

const resolvers = {
  Mutation: {
    createUser: async (_, { input }, context) => {
      try {
        // Validate input
        if (!input.email.includes('@')) {
          throw new ValidationError('Invalid email', 'email');
        }

        // Create user
        const user = await context.users.create(input);
        
        // Publish event
        pubsub.publish('USER_CREATED', { userCreated: user });
        
        return user;
      } catch (error) {
        if (error instanceof ValidationError) {
          throw error;
        }
        throw new ApolloError('Failed to create user', 'CREATE_ERROR', {
          originalError: error
        });
      }
    }
  }
};

// Error formatting
const formatError = (error) => {
  const { originalError } = error;
  
  if (originalError instanceof ValidationError) {
    return {
      message: originalError.message,
      field: originalError.field,
      code: 'VALIDATION_ERROR'
    };
  }
  
  return {
    message: 'Internal server error',
    code: 'INTERNAL_ERROR'
  };
};

const server = new ApolloServer({
  typeDefs,
  resolvers,
  formatError
});
```

---

### 310. What is the purpose of GraphQL data loaders?
**Answer:**
- Batch similar requests
- Cache repeated requests
- Reduce database load
- Optimize query performance

```javascript
const DataLoader = require('dataloader');

class DataLoaders {
  constructor() {
    this.userLoader = new DataLoader(this.batchUsers);
    this.postLoader = new DataLoader(this.batchPosts);
  }

  // Batch user requests
  async batchUsers(ids) {
    const users = await User.find({ _id: { $in: ids } });
    return ids.map(id => users.find(u => u.id === id));
  }

  // Batch post requests
  async batchPosts(ids) {
    const posts = await Post.find({ _id: { $in: ids } });
    return ids.map(id => posts.find(p => p.id === id));
  }

  // Clear cache
  clearCache() {
    this.userLoader.clearAll();
    this.postLoader.clearAll();
  }
}

// Usage in resolvers
const resolvers = {
  Query: {
    user: (_, { id }, { dataLoaders }) => {
      return dataLoaders.userLoader.load(id);
    }
  },
  User: {
    posts: (user, _, { dataLoaders }) => {
      return dataLoaders.postLoader.loadMany(user.postIds);
    }
  }
};

// Context setup
const context = () => ({
  dataLoaders: new DataLoaders()
});
```

# Serverless Architecture (311-320)

### 311. How do you implement serverless functions in Node.js?
**Answer:**
- Use AWS Lambda or similar serverless platforms
- Implement function handlers
- Handle cold starts
- Manage dependencies

```javascript
// AWS Lambda function example
const AWS = require('aws-sdk');
const dynamoDB = new AWS.DynamoDB.DocumentClient();

exports.handler = async (event, context) => {
  try {
    // Parse request body
    const body = JSON.parse(event.body);
    
    // Process request
    const result = await processRequest(body);
    
    // Store in DynamoDB
    await dynamoDB.put({
      TableName: 'Results',
      Item: {
        id: context.awsRequestId,
        result,
        timestamp: new Date().toISOString()
      }
    }).promise();
    
    return {
      statusCode: 200,
      body: JSON.stringify({ success: true, data: result })
    };
  } catch (error) {
    return {
      statusCode: 500,
      body: JSON.stringify({ error: error.message })
    };
  }
};

// Optimize for cold starts
const warmup = async () => {
  // Initialize connections
  await dynamoDB.describeTable({ TableName: 'Results' }).promise();
};

// Call warmup on initialization
warmup();
```

---

### 312. What is the difference between serverless and traditional architecture?
**Answer:**
- Serverless is event-driven, traditional is request-driven
- Serverless scales automatically, traditional requires manual scaling
- Serverless has pay-per-use pricing, traditional has fixed costs
- Serverless has cold starts, traditional is always running

```javascript
// Traditional Express.js server
const express = require('express');
const app = express();

app.get('/api/users', async (req, res) => {
  const users = await User.find();
  res.json(users);
});

app.listen(3000, () => {
  console.log('Server running on port 3000');
});

// Serverless function
exports.handler = async (event) => {
  const users = await User.find();
  return {
    statusCode: 200,
    body: JSON.stringify(users)
  };
};

// Serverless with API Gateway
const serverless = require('serverless-http');
const app = express();

app.get('/api/users', async (req, res) => {
  const users = await User.find();
  res.json(users);
});

module.exports.handler = serverless(app);
```

---

### 313. How do you handle serverless cold starts?
**Answer:**
- Implement warm-up functions
- Use provisioned concurrency
- Optimize package size
- Cache connections

```javascript
const AWS = require('aws-sdk');
let dynamoDB;

// Initialize connections outside handler
const initializeConnections = async () => {
  if (!dynamoDB) {
    dynamoDB = new AWS.DynamoDB.DocumentClient();
    // Warm up connection
    await dynamoDB.describeTable({ TableName: 'Users' }).promise();
  }
  return dynamoDB;
};

// Warm-up function
exports.warmup = async () => {
  await initializeConnections();
  return { status: 'warmed' };
};

// Main function
exports.handler = async (event) => {
  const db = await initializeConnections();
  
  // Use warmed connection
  const result = await db.get({
    TableName: 'Users',
    Key: { id: event.pathParameters.id }
  }).promise();
  
  return {
    statusCode: 200,
    body: JSON.stringify(result.Item)
  };
};
```

---

### 314. What is the purpose of serverless frameworks?
**Answer:**
- Simplify deployment
- Manage infrastructure
- Handle local development
- Configure resources

```javascript
// serverless.yml configuration
const serverless = {
  service: 'user-service',
  provider: {
    name: 'aws',
    runtime: 'nodejs14.x',
    region: 'us-east-1',
    environment: {
      DB_TABLE: '${self:service}-${opt:stage}'
    }
  },
  functions: {
    createUser: {
      handler: 'handlers/createUser.handler',
      events: [
        {
          http: {
            path: 'users',
            method: 'post',
            cors: true
          }
        }
      ]
    },
    getUser: {
      handler: 'handlers/getUser.handler',
      events: [
        {
          http: {
            path: 'users/{id}',
            method: 'get',
            cors: true
          }
        }
      ]
    }
  },
  resources: {
    Resources: {
      UsersTable: {
        Type: 'AWS::DynamoDB::Table',
        Properties: {
          TableName: '${self:provider.environment.DB_TABLE}',
          AttributeDefinitions: [
            { AttributeName: 'id', AttributeType: 'S' }
          ],
          KeySchema: [
            { AttributeName: 'id', KeyType: 'HASH' }
          ],
          ProvisionedThroughput: {
            ReadCapacityUnits: 5,
            WriteCapacityUnits: 5
          }
        }
      }
    }
  }
};
```

---

### 315. How do you implement serverless authentication?
**Answer:**
- Use Cognito or similar services
- Implement JWT validation
- Handle authorization
- Manage user sessions

```javascript
const { CognitoJwtVerifier } = require('aws-jwt-verify');
const verifier = CognitoJwtVerifier.create({
  userPoolId: process.env.USER_POOL_ID,
  tokenUse: 'access',
  clientId: process.env.CLIENT_ID
});

// Authentication middleware
const authenticate = async (event) => {
  try {
    const token = event.headers.Authorization?.replace('Bearer ', '');
    if (!token) {
      throw new Error('No token provided');
    }
    
    const payload = await verifier.verify(token);
    return {
      ...event,
      user: payload
    };
  } catch (error) {
    throw new Error('Unauthorized');
  }
};

// Protected function
exports.handler = async (event) => {
  try {
    // Authenticate request
    const authenticatedEvent = await authenticate(event);
    
    // Process request
    const result = await processRequest(authenticatedEvent);
    
    return {
      statusCode: 200,
      body: JSON.stringify(result)
    };
  } catch (error) {
    return {
      statusCode: error.message === 'Unauthorized' ? 401 : 500,
      body: JSON.stringify({ error: error.message })
    };
  }
};
```

---

### 316. What is the purpose of serverless monitoring?
**Answer:**
- Track function performance
- Monitor resource usage
- Set up alerts
- Analyze costs

```javascript
const AWS = require('aws-sdk');
const cloudWatch = new AWS.CloudWatch();

class ServerlessMonitor {
  constructor(functionName) {
    this.functionName = functionName;
  }

  async recordMetric(name, value, unit = 'Count') {
    await cloudWatch.putMetricData({
      Namespace: 'ServerlessApp',
      MetricData: [{
        MetricName: name,
        Value: value,
        Unit: unit,
        Dimensions: [
          { Name: 'FunctionName', Value: this.functionName }
        ]
      }]
    }).promise();
  }

  async monitorFunction(handler) {
    return async (event, context) => {
      const startTime = Date.now();
      
      try {
        const result = await handler(event, context);
        
        // Record success metrics
        await this.recordMetric('Success', 1);
        await this.recordMetric('Duration', Date.now() - startTime, 'Milliseconds');
        
        return result;
      } catch (error) {
        // Record error metrics
        await this.recordMetric('Errors', 1);
        throw error;
      }
    };
  }
}

// Usage
const monitor = new ServerlessMonitor('myFunction');
exports.handler = monitor.monitorFunction(async (event) => {
  // Function logic
});
```

---

### 317. How do you handle serverless state management?
**Answer:**
- Use external storage services
- Implement caching
- Handle distributed state
- Manage session data

```javascript
const AWS = require('aws-sdk');
const dynamoDB = new AWS.DynamoDB.DocumentClient();
const redis = require('redis');

class StateManager {
  constructor() {
    this.redis = redis.createClient({
      host: process.env.REDIS_HOST,
      port: process.env.REDIS_PORT
    });
  }

  async getState(key) {
    // Try cache first
    const cached = await this.redis.get(key);
    if (cached) return JSON.parse(cached);
    
    // Fall back to DynamoDB
    const result = await dynamoDB.get({
      TableName: 'State',
      Key: { id: key }
    }).promise();
    
    if (result.Item) {
      // Cache for future requests
      await this.redis.set(key, JSON.stringify(result.Item), 'EX', 3600);
      return result.Item;
    }
    
    return null;
  }

  async setState(key, value) {
    // Update DynamoDB
    await dynamoDB.put({
      TableName: 'State',
      Item: {
        id: key,
        value,
        timestamp: Date.now()
      }
    }).promise();
    
    // Update cache
    await this.redis.set(key, JSON.stringify(value), 'EX', 3600);
  }
}

// Usage in function
const stateManager = new StateManager();

exports.handler = async (event) => {
  const state = await stateManager.getState('user-session');
  // Use state
  await stateManager.setState('user-session', { ...state, lastAccess: Date.now() });
};
```

---

### 318. What is the purpose of serverless deployment?
**Answer:**
- Package and deploy functions
- Manage environments
- Handle rollbacks
- Configure resources

```javascript
// serverless.yml deployment configuration
const deployment = {
  service: 'user-service',
  provider: {
    name: 'aws',
    runtime: 'nodejs14.x',
    stage: '${opt:stage, "dev"}',
    region: '${opt:region, "us-east-1"}',
    deploymentMethod: 'direct'
  },
  package: {
    individually: true,
    patterns: [
      '!node_modules/**',
      '!tests/**',
      '!.git/**'
    ]
  },
  custom: {
    stages: {
      dev: {
        domain: 'dev-api.example.com'
      },
      prod: {
        domain: 'api.example.com'
      }
    }
  },
  plugins: [
    'serverless-offline',
    'serverless-domain-manager'
  ],
  resources: {
    Conditions: {
      IsProd: { 'Fn::Equals': ['${opt:stage}', 'prod'] }
    },
    Resources: {
      // Production-only resources
      ProdResource: {
        Condition: 'IsProd',
        Type: 'AWS::S3::Bucket',
        Properties: {
          BucketName: 'prod-data-${self:service}'
        }
      }
    }
  }
};
```

---

### 319. How do you implement serverless testing?
**Answer:**
- Test functions locally
- Mock AWS services
- Test integrations
- Validate deployments

```javascript
const { expect } = require('chai');
const AWS = require('aws-sdk-mock');
const { handler } = require('../functions/createUser');

describe('Create User Function', () => {
  beforeEach(() => {
    // Mock DynamoDB
    AWS.mock('DynamoDB.DocumentClient', 'put', (params, callback) => {
      callback(null, {});
    });
  });

  afterEach(() => {
    AWS.restore();
  });

  it('should create a user successfully', async () => {
    const event = {
      body: JSON.stringify({
        name: 'John Doe',
        email: 'john@example.com'
      })
    };

    const result = await handler(event);
    
    expect(result.statusCode).to.equal(200);
    expect(JSON.parse(result.body)).to.have.property('success', true);
  });

  it('should handle validation errors', async () => {
    const event = {
      body: JSON.stringify({
        name: 'John Doe'
        // Missing email
      })
    };

    const result = await handler(event);
    
    expect(result.statusCode).to.equal(400);
    expect(JSON.parse(result.body)).to.have.property('error');
  });
});
```

---

### 320. What is the purpose of serverless security?
**Answer:**
- Secure function access
- Protect sensitive data
- Implement encryption
- Manage permissions

```javascript
const AWS = require('aws-sdk');
const kms = new AWS.KMS();

class SecurityManager {
  constructor() {
    this.encryptionKey = process.env.ENCRYPTION_KEY;
  }

  async encrypt(data) {
    const params = {
      KeyId: this.encryptionKey,
      Plaintext: JSON.stringify(data)
    };
    
    const result = await kms.encrypt(params).promise();
    return result.CiphertextBlob.toString('base64');
  }

  async decrypt(encryptedData) {
    const params = {
      CiphertextBlob: Buffer.from(encryptedData, 'base64')
    };
    
    const result = await kms.decrypt(params).promise();
    return JSON.parse(result.Plaintext.toString());
  }
}

// Secure function
const securityManager = new SecurityManager();

exports.handler = async (event) => {
  try {
    // Validate request
    if (!event.headers['X-API-Key']) {
      throw new Error('Missing API key');
    }
    
    // Process sensitive data
    const sensitiveData = {
      creditCard: '4111111111111111',
      ssn: '123-45-6789'
    };
    
    // Encrypt data
    const encrypted = await securityManager.encrypt(sensitiveData);
    
    // Store encrypted data
    await storeData(encrypted);
    
    return {
      statusCode: 200,
      body: JSON.stringify({ success: true })
    };
  } catch (error) {
    return {
      statusCode: 500,
      body: JSON.stringify({ error: error.message })
    };
  }
};
```

# Internationalization (i18n) (341-350)

### 341. How do you implement internationalization in Node.js?
**Answer:**
- Use i18n libraries
- Handle translations
- Manage locales
- Support multiple languages

```typescript
// i18n configuration
import i18n from 'i18next';
import { initReactI18next } from 'react-i18next';
import Backend from 'i18next-fs-backend';

i18n
  .use(Backend)
  .use(initReactI18next)
  .init({
    lng: 'en',
    fallbackLng: 'en',
    ns: ['common', 'errors'],
    defaultNS: 'common',
    backend: {
      loadPath: './locales/{{lng}}/{{ns}}.json'
    },
    interpolation: {
      escapeValue: false
    }
  });

// Translation files
// locales/en/common.json
{
  "welcome": "Welcome",
  "hello": "Hello, {{name}}!",
  "buttons": {
    "submit": "Submit",
    "cancel": "Cancel"
  }
}

// locales/es/common.json
{
  "welcome": "Bienvenido",
  "hello": "Â¡Hola, {{name}}!",
  "buttons": {
    "submit": "Enviar",
    "cancel": "Cancelar"
  }
}

// Usage in Express
app.use(i18n.init);

app.get('/', (req, res) => {
  res.send(req.t('welcome'));
});

app.get('/greet/:name', (req, res) => {
  res.send(req.t('hello', { name: req.params.name }));
});
```

---

### 342. What is the purpose of i18n middleware?
**Answer:**
- Detect user language
- Load translations
- Handle locale switching
- Manage language preferences

```typescript
// i18n middleware
class I18nMiddleware {
  private static instance: I18nMiddleware;
  private supportedLocales: string[] = ['en', 'es', 'fr'];

  private constructor() {}

  static getInstance(): I18nMiddleware {
    if (!I18nMiddleware.instance) {
      I18nMiddleware.instance = new I18nMiddleware();
    }
    return I18nMiddleware.instance;
  }

  middleware() {
    return async (req: Request, res: Response, next: NextFunction) => {
      // Detect language from headers
      const acceptLanguage = req.headers['accept-language'];
      const preferredLocale = this.detectLocale(acceptLanguage);
      
      // Set locale in request
      req.locale = preferredLocale;
      
      // Load translations
      await this.loadTranslations(req, preferredLocale);
      
      next();
    };
  }

  private detectLocale(acceptLanguage: string): string {
    if (!acceptLanguage) return 'en';
    
    const locales = acceptLanguage.split(',')
      .map(lang => lang.split(';')[0].trim());
    
    return locales.find(locale => 
      this.supportedLocales.includes(locale)
    ) || 'en';
  }

  private async loadTranslations(req: Request, locale: string): Promise<void> {
    const translations = await this.loadTranslationFiles(locale);
    req.translations = translations;
  }

  private async loadTranslationFiles(locale: string): Promise<any> {
    // Implementation for loading translation files
  }
}

// Usage in Express
const i18nMiddleware = I18nMiddleware.getInstance();
app.use(i18nMiddleware.middleware());
```

---

### 343. How do you handle translations?
**Answer:**
- Manage translation files
- Handle pluralization
- Support interpolation
- Implement fallbacks

```typescript
// Translation manager
class TranslationManager {
  private static instance: TranslationManager;
  private translations: Map<string, Map<string, any>> = new Map();

  private constructor() {}

  static getInstance(): TranslationManager {
    if (!TranslationManager.instance) {
      TranslationManager.instance = new TranslationManager();
    }
    return TranslationManager.instance;
  }

  async loadTranslations(locale: string): Promise<void> {
    const translations = await this.loadTranslationFiles(locale);
    this.translations.set(locale, translations);
  }

  translate(key: string, locale: string, params?: any): string {
    const translation = this.getTranslation(key, locale);
    return this.interpolate(translation, params);
  }

  private getTranslation(key: string, locale: string): string {
    const localeTranslations = this.translations.get(locale);
    if (!localeTranslations) {
      return this.getFallbackTranslation(key);
    }

    const translation = this.getNestedValue(localeTranslations, key);
    return translation || this.getFallbackTranslation(key);
  }

  private interpolate(text: string, params?: any): string {
    if (!params) return text;
    
    return text.replace(/\{\{(\w+)\}\}/g, (_, key) => {
      return params[key] || '';
    });
  }

  private getFallbackTranslation(key: string): string {
    // Implementation for fallback translations
    return '';
  }
}

// Usage
const translationManager = TranslationManager.getInstance();

// Load translations
await translationManager.loadTranslations('en');

// Translate
const message = translationManager.translate('hello', 'en', { name: 'John' });
```

---

### 344. What is the purpose of locale detection?
**Answer:**
- Identify user language
- Set default locale
- Handle language preferences
- Support multiple locales

```typescript
// Locale detector
class LocaleDetector {
  private static instance: LocaleDetector;
  private supportedLocales: string[] = ['en', 'es', 'fr'];
  private defaultLocale: string = 'en';

  private constructor() {}

  static getInstance(): LocaleDetector {
    if (!LocaleDetector.instance) {
      LocaleDetector.instance = new LocaleDetector();
    }
    return LocaleDetector.instance;
  }

  detectLocale(req: Request): string {
    // Check query parameter
    if (req.query.lang && this.isSupported(req.query.lang)) {
      return req.query.lang;
    }

    // Check cookie
    if (req.cookies.locale && this.isSupported(req.cookies.locale)) {
      return req.cookies.locale;
    }

    // Check Accept-Language header
    const acceptLanguage = req.headers['accept-language'];
    if (acceptLanguage) {
      const preferredLocale = this.parseAcceptLanguage(acceptLanguage);
      if (preferredLocale) {
        return preferredLocale;
      }
    }

    return this.defaultLocale;
  }

  private isSupported(locale: string): boolean {
    return this.supportedLocales.includes(locale);
  }

  private parseAcceptLanguage(acceptLanguage: string): string | null {
    const locales = acceptLanguage.split(',')
      .map(lang => lang.split(';')[0].trim());
    
    return locales.find(locale => this.isSupported(locale)) || null;
  }
}

// Usage in Express
const localeDetector = LocaleDetector.getInstance();

app.use((req: Request, res: Response, next: NextFunction) => {
  const locale = localeDetector.detectLocale(req);
  req.locale = locale;
  next();
});
```

---

### 345. How do you implement date formatting?
**Answer:**
- Use date formatting libraries
- Handle time zones
- Support multiple formats
- Manage locale-specific formats

```typescript
// Date formatter
class DateFormatter {
  private static instance: DateFormatter;
  private formatters: Map<string, Intl.DateTimeFormat> = new Map();

  private constructor() {}

  static getInstance(): DateFormatter {
    if (!DateFormatter.instance) {
      DateFormatter.instance = new DateFormatter();
    }
    return DateFormatter.instance;
  }

  formatDate(date: Date, locale: string, options: Intl.DateTimeFormatOptions): string {
    const formatter = this.getFormatter(locale, options);
    return formatter.format(date);
  }

  formatRelativeTime(date: Date, locale: string): string {
    const now = new Date();
    const diff = now.getTime() - date.getTime();
    
    const rtf = new Intl.RelativeTimeFormat(locale, { numeric: 'auto' });
    
    const seconds = Math.floor(diff / 1000);
    const minutes = Math.floor(seconds / 60);
    const hours = Math.floor(minutes / 60);
    const days = Math.floor(hours / 24);
    
    if (days > 0) return rtf.format(-days, 'day');
    if (hours > 0) return rtf.format(-hours, 'hour');
    if (minutes > 0) return rtf.format(-minutes, 'minute');
    return rtf.format(-seconds, 'second');
  }

  private getFormatter(locale: string, options: Intl.DateTimeFormatOptions): Intl.DateTimeFormat {
    const key = `${locale}-${JSON.stringify(options)}`;
    
    if (!this.formatters.has(key)) {
      this.formatters.set(key, new Intl.DateTimeFormat(locale, options));
    }
    
    return this.formatters.get(key);
  }
}

// Usage
const dateFormatter = DateFormatter.getInstance();

// Format date
const date = new Date();
const formattedDate = dateFormatter.formatDate(date, 'en-US', {
  year: 'numeric',
  month: 'long',
  day: 'numeric'
});

// Format relative time
const relativeTime = dateFormatter.formatRelativeTime(date, 'en-US');
```

---

### 346. What is the purpose of number formatting?
**Answer:**
- Format numbers by locale
- Handle currency
- Support different formats
- Manage decimal places

```typescript
// Number formatter
class NumberFormatter {
  private static instance: NumberFormatter;
  private formatters: Map<string, Intl.NumberFormat> = new Map();

  private constructor() {}

  static getInstance(): NumberFormatter {
    if (!NumberFormatter.instance) {
      NumberFormatter.instance = new NumberFormatter();
    }
    return NumberFormatter.instance;
  }

  formatNumber(number: number, locale: string, options: Intl.NumberFormatOptions): string {
    const formatter = this.getFormatter(locale, options);
    return formatter.format(number);
  }

  formatCurrency(amount: number, locale: string, currency: string): string {
    const formatter = this.getFormatter(locale, {
      style: 'currency',
      currency
    });
    return formatter.format(amount);
  }

  formatPercent(value: number, locale: string): string {
    const formatter = this.getFormatter(locale, {
      style: 'percent',
      minimumFractionDigits: 2,
      maximumFractionDigits: 2
    });
    return formatter.format(value);
  }

  private getFormatter(locale: string, options: Intl.NumberFormatOptions): Intl.NumberFormat {
    const key = `${locale}-${JSON.stringify(options)}`;
    
    if (!this.formatters.has(key)) {
      this.formatters.set(key, new Intl.NumberFormat(locale, options));
    }
    
    return this.formatters.get(key);
  }
}

// Usage
const numberFormatter = NumberFormatter.getInstance();

// Format number
const number = 1234567.89;
const formattedNumber = numberFormatter.formatNumber(number, 'en-US', {
  minimumFractionDigits: 2,
  maximumFractionDigits: 2
});

// Format currency
const amount = 99.99;
const formattedCurrency = numberFormatter.formatCurrency(amount, 'en-US', 'USD');

// Format percent
const percent = 0.1234;
const formattedPercent = numberFormatter.formatPercent(percent, 'en-US');
```

---

### 347. How do you handle currency formatting?
**Answer:**
- Format currency by locale
- Handle exchange rates
- Support multiple currencies
- Manage currency symbols

```typescript
// Currency formatter
class CurrencyFormatter {
  private static instance: CurrencyFormatter;
  private formatters: Map<string, Intl.NumberFormat> = new Map();
  private exchangeRates: Map<string, number> = new Map();

  private constructor() {
    this.initializeExchangeRates();
  }

  static getInstance(): CurrencyFormatter {
    if (!CurrencyFormatter.instance) {
      CurrencyFormatter.instance = new CurrencyFormatter();
    }
    return CurrencyFormatter.instance;
  }

  formatCurrency(amount: number, locale: string, currency: string): string {
    const formatter = this.getFormatter(locale, currency);
    return formatter.format(amount);
  }

  async convertCurrency(amount: number, fromCurrency: string, toCurrency: string): Promise<number> {
    const rate = await this.getExchangeRate(fromCurrency, toCurrency);
    return amount * rate;
  }

  private getFormatter(locale: string, currency: string): Intl.NumberFormat {
    const key = `${locale}-${currency}`;
    
    if (!this.formatters.has(key)) {
      this.formatters.set(key, new Intl.NumberFormat(locale, {
        style: 'currency',
        currency
      }));
    }
    
    return this.formatters.get(key);
  }

  private async getExchangeRate(fromCurrency: string, toCurrency: string): Promise<number> {
    // Implementation for fetching exchange rates
    return this.exchangeRates.get(`${fromCurrency}-${toCurrency}`) || 1;
  }

  private initializeExchangeRates(): void {
    // Implementation for initializing exchange rates
  }
}

// Usage
const currencyFormatter = CurrencyFormatter.getInstance();

// Format currency
const amount = 99.99;
const formattedAmount = currencyFormatter.formatCurrency(amount, 'en-US', 'USD');

// Convert currency
const convertedAmount = await currencyFormatter.convertCurrency(amount, 'USD', 'EUR');
const formattedConvertedAmount = currencyFormatter.formatCurrency(convertedAmount, 'en-US', 'EUR');
```

---

### 348. What is the purpose of pluralization?
**Answer:**
- Handle plural forms
- Support multiple languages
- Manage plural rules
- Format plural messages

```typescript
// Pluralization manager
class PluralizationManager {
  private static instance: PluralizationManager;
  private pluralRules: Map<string, Intl.PluralRules> = new Map();

  private constructor() {}

  static getInstance(): PluralizationManager {
    if (!PluralizationManager.instance) {
      PluralizationManager.instance = new PluralizationManager();
    }
    return PluralizationManager.instance;
  }

  getPluralForm(number: number, locale: string): string {
    const rules = this.getPluralRules(locale);
    return rules.select(number);
  }

  formatPluralMessage(key: string, number: number, locale: string): string {
    const pluralForm = this.getPluralForm(number, locale);
    const message = this.getPluralMessage(key, pluralForm, locale);
    return message.replace('{{count}}', number.toString());
  }

  private getPluralRules(locale: string): Intl.PluralRules {
    if (!this.pluralRules.has(locale)) {
      this.pluralRules.set(locale, new Intl.PluralRules(locale));
    }
    return this.pluralRules.get(locale);
  }

  private getPluralMessage(key: string, pluralForm: string, locale: string): string {
    // Implementation for getting plural messages
    return '';
  }
}

// Usage
const pluralizationManager = PluralizationManager.getInstance();

// Format plural message
const count = 5;
const message = pluralizationManager.formatPluralMessage('items', count, 'en-US');
// "5 items"

const count2 = 1;
const message2 = pluralizationManager.formatPluralMessage('items', count2, 'en-US');
// "1 item"
```

---

### 349. How do you implement RTL support?
**Answer:**
- Handle right-to-left languages
- Support bidirectional text
- Manage layout direction
- Implement RTL styles

```typescript
// RTL manager
class RTLManager {
  private static instance: RTLManager;
  private rtlLanguages: Set<string> = new Set(['ar', 'he', 'fa']);

  private constructor() {}

  static getInstance(): RTLManager {
    if (!RTLManager.instance) {
      RTLManager.instance = new RTLManager();
    }
    return RTLManager.instance;
  }

  isRTL(locale: string): boolean {
    return this.rtlLanguages.has(locale);
  }

  getTextDirection(locale: string): 'rtl' | 'ltr' {
    return this.isRTL(locale) ? 'rtl' : 'ltr';
  }

  formatBidirectionalText(text: string, locale: string): string {
    if (!this.isRTL(locale)) return text;
    
    // Add RTL mark
    return `\u202E${text}\u202C`;
  }

  getRTLStyles(locale: string): any {
    return this.isRTL(locale) ? {
      direction: 'rtl',
      textAlign: 'right'
    } : {
      direction: 'ltr',
      textAlign: 'left'
    };
  }
}

// Usage in Express
const rtlManager = RTLManager.getInstance();

app.use((req: Request, res: Response, next: NextFunction) => {
  const locale = req.locale || 'en';
  req.isRTL = rtlManager.isRTL(locale);
  req.textDirection = rtlManager.getTextDirection(locale);
  next();
});

// Usage in template
app.get('/', (req: Request, res: Response) => {
  res.render('index', {
    isRTL: req.isRTL,
    textDirection: req.textDirection,
    styles: rtlManager.getRTLStyles(req.locale)
  });
});
```

---

### 350. What is the purpose of i18n testing?
**Answer:**
- Verify translations
- Test locale detection
- Validate formatting
- Check pluralization

```typescript
// i18n test suite
class I18nTester {
  private static instance: I18nTester;
  private translationManager: TranslationManager;
  private localeDetector: LocaleDetector;

  private constructor() {
    this.translationManager = TranslationManager.getInstance();
    this.localeDetector = LocaleDetector.getInstance();
  }

  static getInstance(): I18nTester {
    if (!I18nTester.instance) {
      I18nTester.instance = new I18nTester();
    }
    return I18nTester.instance;
  }

  async testTranslations(): Promise<TestResult[]> {
    const results: TestResult[] = [];
    const locales = ['en', 'es', 'fr'];
    
    for (const locale of locales) {
      await this.translationManager.loadTranslations(locale);
      
      // Test common keys
      const commonKeys = ['welcome', 'hello', 'goodbye'];
      for (const key of commonKeys) {
        const translation = this.translationManager.translate(key, locale);
        results.push({
          type: 'translation',
          locale,
          key,
          success: !!translation,
          message: translation || 'Missing translation'
        });
      }
    }
    
    return results;
  }

  testLocaleDetection(): TestResult[] {
    const results: TestResult[] = [];
    const testCases = [
      { header: 'en-US,en;q=0.9', expected: 'en' },
      { header: 'es-ES,es;q=0.9', expected: 'es' },
      { header: 'fr-FR,fr;q=0.9', expected: 'fr' }
    ];
    
    for (const testCase of testCases) {
      const req = { headers: { 'accept-language': testCase.header } } as Request;
      const detectedLocale = this.localeDetector.detectLocale(req);
      
      results.push({
        type: 'locale',
        input: testCase.header,
        expected: testCase.expected,
        actual: detectedLocale,
        success: detectedLocale === testCase.expected
      });
    }
    
    return results;
  }
}

// Usage
const i18nTester = I18nTester.getInstance();

// Run tests
async function runTests() {
  const translationResults = await i18nTester.testTranslations();
  const localeResults = i18nTester.testLocaleDetection();
  
  console.log('Translation Test Results:', translationResults);
  console.log('Locale Detection Results:', localeResults);
}
```
