# Node.js Interview Questions and Answers (51-75)

## Database Integration

### 51. How do you connect to MongoDB using Node.js?

**Answer:**
MongoDB can be connected using the official MongoDB driver or Mongoose ODM. Here's how to do it with both approaches:

**Example using MongoDB driver:**
```javascript
const { MongoClient } = require('mongodb');

async function connectToMongo() {
    try {
        const client = new MongoClient('mongodb://localhost:27017');
        await client.connect();
        console.log('Connected to MongoDB');
        return client.db('mydatabase');
    } catch (error) {
        console.error('Connection error:', error);
        throw error;
    }
}

// Usage
connectToMongo()
    .then(db => {
        // Use db object for operations
    })
    .catch(console.error);
```

### 52. What is Mongoose and how do you use it?

**Answer:**
Mongoose is an Object Data Modeling (ODM) library for MongoDB and Node.js. It provides:
- Schema definition
- Data validation
- Middleware
- Type casting
- Query building

**Example:**
```javascript
const mongoose = require('mongoose');

// Define Schema
const userSchema = new mongoose.Schema({
    name: { type: String, required: true },
    email: { type: String, required: true, unique: true },
    age: { type: Number, min: 0 }
});

// Create Model
const User = mongoose.model('User', userSchema);

// Connect to MongoDB
mongoose.connect('mongodb://localhost:27017/mydatabase');

// Create and save document
async function createUser() {
    try {
        const user = new User({
            name: 'John Doe',
            email: 'john@example.com',
            age: 30
        });
        await user.save();
        console.log('User saved successfully');
    } catch (error) {
        console.error('Error:', error);
    }
}
```

### 53. How do you perform CRUD operations in MongoDB?

**Answer:**
CRUD operations in MongoDB can be performed using either the MongoDB driver or Mongoose:

**Example using Mongoose:**
```javascript
const User = require('./models/user');

// Create
async function createUser(userData) {
    const user = new User(userData);
    return await user.save();
}

// Read
async function getUsers() {
    return await User.find();
}

async function getUserById(id) {
    return await User.findById(id);
}

// Update
async function updateUser(id, updateData) {
    return await User.findByIdAndUpdate(id, updateData, { new: true });
}

// Delete
async function deleteUser(id) {
    return await User.findByIdAndDelete(id);
}
```

### 54. What is the difference between SQL and NoSQL databases?

**Answer:**
Key differences between SQL and NoSQL databases:

SQL (e.g., MySQL, PostgreSQL):
- Structured data with predefined schema
- ACID compliance
- Vertical scaling
- Better for complex queries
- Strong data consistency

NoSQL (e.g., MongoDB, Redis):
- Flexible schema
- Horizontal scaling
- Better for large datasets
- Eventual consistency
- Better performance for simple queries

**Example:**
```javascript
// SQL (using MySQL)
const mysql = require('mysql2/promise');

async function sqlExample() {
    const connection = await mysql.createConnection({
        host: 'localhost',
        user: 'root',
        database: 'mydb'
    });

    // Structured query with joins
    const [rows] = await connection.execute(`
        SELECT users.name, orders.product
        FROM users
        JOIN orders ON users.id = orders.user_id
    `);
}

// NoSQL (using MongoDB)
const mongoose = require('mongoose');

async function nosqlExample() {
    // Flexible document structure
    const user = {
        name: 'John',
        orders: [
            { product: 'Laptop', price: 1000 },
            { product: 'Phone', price: 500 }
        ]
    };
    await User.create(user);
}
```

### 55. How do you handle database transactions in Node.js?

**Answer:**
Database transactions ensure data integrity across multiple operations. Here's how to handle them:

**Example using MongoDB:**
```javascript
const mongoose = require('mongoose');

async function transferMoney(fromAccountId, toAccountId, amount) {
    const session = await mongoose.startSession();
    session.startTransaction();

    try {
        // Debit from account
        await Account.findByIdAndUpdate(
            fromAccountId,
            { $inc: { balance: -amount } },
            { session }
        );

        // Credit to account
        await Account.findByIdAndUpdate(
            toAccountId,
            { $inc: { balance: amount } },
            { session }
        );

        await session.commitTransaction();
        console.log('Transaction successful');
    } catch (error) {
        await session.abortTransaction();
        console.error('Transaction failed:', error);
        throw error;
    } finally {
        session.endSession();
    }
}
```

### 56. What is connection pooling and how do you implement it?

**Answer:**
Connection pooling maintains a pool of database connections to improve performance. Here's how to implement it:

**Example using MongoDB:**
```javascript
const mongoose = require('mongoose');

const options = {
    poolSize: 10,
    serverSelectionTimeoutMS: 5000,
    socketTimeoutMS: 45000,
};

mongoose.connect('mongodb://localhost:27017/mydatabase', options);

// Monitor connection events
mongoose.connection.on('connected', () => {
    console.log('Mongoose connected');
});

mongoose.connection.on('error', (err) => {
    console.error('Mongoose connection error:', err);
});

mongoose.connection.on('disconnected', () => {
    console.log('Mongoose disconnected');
});
```

### 57. How do you implement caching in Node.js?

**Answer:**
Caching can be implemented using:
- In-memory caching
- Redis
- Memcached
- Browser caching

**Example using Redis:**
```javascript
const redis = require('redis');
const client = redis.createClient();

async function getCachedData(key) {
    try {
        // Check cache first
        const cachedData = await client.get(key);
        if (cachedData) {
            return JSON.parse(cachedData);
        }

        // If not in cache, get from database
        const data = await fetchFromDatabase();
        
        // Store in cache
        await client.set(key, JSON.stringify(data), 'EX', 3600); // Expire in 1 hour
        
        return data;
    } catch (error) {
        console.error('Cache error:', error);
        throw error;
    }
}
```

### 58. What is Redis and how do you use it with Node.js?

**Answer:**
Redis is an in-memory data structure store used for:
- Caching
- Session storage
- Message broker
- Real-time analytics

**Example:**
```javascript
const redis = require('redis');
const client = redis.createClient();

// Basic operations
async function redisExample() {
    // Set value
    await client.set('key', 'value');
    
    // Get value
    const value = await client.get('key');
    
    // Set with expiration
    await client.set('temp', 'data', 'EX', 60);
    
    // List operations
    await client.lPush('list', 'item1');
    await client.lPush('list', 'item2');
    
    // Hash operations
    await client.hSet('user:1', {
        name: 'John',
        email: 'john@example.com'
    });
}
```

### 59. How do you handle database migrations?

**Answer:**
Database migrations can be handled using:
- Mongoose migrations
- Custom migration scripts
- Migration libraries

**Example using custom migration:**
```javascript
const mongoose = require('mongoose');

async function migrateDatabase() {
    try {
        // Connect to database
        await mongoose.connect('mongodb://localhost:27017/mydatabase');

        // Add new field to all documents
        await User.updateMany(
            { age: { $exists: false } },
            { $set: { age: 0 } }
        );

        // Rename field
        await User.updateMany(
            { firstName: { $exists: true } },
            [
                { $set: { name: '$firstName' } },
                { $unset: 'firstName' }
            ]
        );

        console.log('Migration completed successfully');
    } catch (error) {
        console.error('Migration failed:', error);
        throw error;
    }
}
```

### 60. What is the purpose of database indexing?

**Answer:**
Database indexing improves query performance by:
- Creating ordered references to data
- Speeding up data retrieval
- Optimizing search operations

**Example using Mongoose:**
```javascript
const mongoose = require('mongoose');

const userSchema = new mongoose.Schema({
    email: { 
        type: String, 
        required: true,
        index: true, // Single field index
        unique: true
    },
    name: String,
    age: Number
});

// Compound index
userSchema.index({ name: 1, age: -1 });

// Text index for search
userSchema.index({ name: 'text', email: 'text' });

const User = mongoose.model('User', userSchema);
```

## Testing and Debugging

### 61. What testing frameworks are commonly used with Node.js?

**Answer:**
Common testing frameworks include:
- Jest
- Mocha
- Chai
- Supertest
- Sinon

**Example using Jest:**
```javascript
// user.test.js
const User = require('./user');

describe('User', () => {
    test('should create user with valid data', () => {
        const user = new User({
            name: 'John',
            email: 'john@example.com'
        });
        expect(user.name).toBe('John');
        expect(user.email).toBe('john@example.com');
    });

    test('should validate email format', () => {
        expect(() => {
            new User({
                name: 'John',
                email: 'invalid-email'
            });
        }).toThrow('Invalid email format');
    });
});
```

### 62. How do you write unit tests in Node.js?

**Answer:**
Unit tests focus on testing individual components in isolation:

**Example using Jest:**
```javascript
// math.js
function add(a, b) {
    return a + b;
}

function subtract(a, b) {
    return a - b;
}

module.exports = { add, subtract };

// math.test.js
const { add, subtract } = require('./math');

describe('Math functions', () => {
    test('adds 1 + 2 to equal 3', () => {
        expect(add(1, 2)).toBe(3);
    });

    test('subtracts 5 - 3 to equal 2', () => {
        expect(subtract(5, 3)).toBe(2);
    });

    test('handles negative numbers', () => {
        expect(add(-1, -2)).toBe(-3);
        expect(subtract(-5, -3)).toBe(-2);
    });
});
```

### 63. What is the difference between unit testing and integration testing?

**Answer:**
Unit testing:
- Tests individual components
- Isolates dependencies
- Fast execution
- Uses mocks/stubs

Integration testing:
- Tests component interactions
- Uses real dependencies
- Slower execution
- Tests workflows

**Example:**
```javascript
// Unit test
describe('UserService', () => {
    let userService;
    let mockUserRepository;

    beforeEach(() => {
        mockUserRepository = {
            findById: jest.fn()
        };
        userService = new UserService(mockUserRepository);
    });

    test('should get user by id', async () => {
        mockUserRepository.findById.mockResolvedValue({ id: 1, name: 'John' });
        const user = await userService.getUser(1);
        expect(user.name).toBe('John');
    });
});

// Integration test
describe('User API', () => {
    test('should create and retrieve user', async () => {
        // Create user
        const response = await request(app)
            .post('/api/users')
            .send({ name: 'John', email: 'john@example.com' });
        expect(response.status).toBe(201);

        // Get user
        const user = await request(app)
            .get(`/api/users/${response.body.id}`);
        expect(user.body.name).toBe('John');
    });
});
```

### 64. How do you debug Node.js applications?

**Answer:**
Debugging can be done using:
- console methods
- Node.js debugger
- IDE debuggers
- Logging libraries

**Example:**
```javascript
// Using console methods
console.log('Debug info:', { key: 'value' });
console.error('Error occurred:', error);
console.time('operation');
// ... code ...
console.timeEnd('operation');

// Using debugger
function complexOperation() {
    debugger; // Breakpoint
    // ... code ...
}

// Using logging library (Winston)
const winston = require('winston');
const logger = winston.createLogger({
    level: 'debug',
    format: winston.format.json(),
    transports: [
        new winston.transports.File({ filename: 'error.log', level: 'error' }),
        new winston.transports.File({ filename: 'combined.log' })
    ]
});

logger.info('Info message');
logger.error('Error message', { error: err });
```

### 65. What is the purpose of the debugger statement?

**Answer:**
The debugger statement creates a breakpoint in the code where execution will pause when debugging is enabled.

**Example:**
```javascript
function processData(data) {
    debugger; // Execution will pause here when debugging
    const result = data.map(item => {
        debugger; // Another breakpoint
        return item * 2;
    });
    return result;
}

// Using with Chrome DevTools
// 1. Start Node with --inspect flag
// 2. Open chrome://inspect
// 3. Click on "Open dedicated DevTools for Node"
```

### 66. How do you use console.log() effectively for debugging?

**Answer:**
Effective console.log usage includes:
- Structured logging
- Different log levels
- Object inspection
- Performance measurement

**Example:**
```javascript
// Basic logging
console.log('User logged in:', username);

// Object inspection
console.log('User object:', {
    name: user.name,
    email: user.email,
    permissions: user.permissions
});

// Table format
console.table([
    { id: 1, name: 'John' },
    { id: 2, name: 'Jane' }
]);

// Performance measurement
console.time('database-query');
await db.query();
console.timeEnd('database-query');

// Stack trace
console.trace('Function called from:');

// Grouping logs
console.group('User Operations');
console.log('Creating user');
console.log('Sending welcome email');
console.log('Updating statistics');
console.groupEnd();
```

### 67. What is the difference between assert and expect in testing?

**Answer:**
- `assert`: Node.js built-in assertion library
- `expect`: Part of testing libraries like Jest/Chai, provides more readable syntax

**Example:**
```javascript
// Using assert
const assert = require('assert');

function testWithAssert() {
    const result = add(2, 3);
    assert.strictEqual(result, 5);
    assert.deepStrictEqual({ a: 1 }, { a: 1 });
}

// Using expect (Jest)
function testWithExpect() {
    const result = add(2, 3);
    expect(result).toBe(5);
    expect({ a: 1 }).toEqual({ a: 1 });
    expect(result).toBeGreaterThan(4);
    expect(result).toBeLessThan(6);
}
```

### 68. How do you mock dependencies in tests?

**Answer:**
Dependencies can be mocked using:
- Jest mock functions
- Sinon stubs/spies
- Manual mocks

**Example using Jest:**
```javascript
// userService.js
class UserService {
    constructor(userRepository) {
        this.userRepository = userRepository;
    }

    async getUser(id) {
        return await this.userRepository.findById(id);
    }
}

// userService.test.js
jest.mock('./userRepository');

describe('UserService', () => {
    let userService;
    let mockUserRepository;

    beforeEach(() => {
        mockUserRepository = {
            findById: jest.fn()
        };
        userService = new UserService(mockUserRepository);
    });

    test('should get user by id', async () => {
        const mockUser = { id: 1, name: 'John' };
        mockUserRepository.findById.mockResolvedValue(mockUser);

        const user = await userService.getUser(1);
        expect(user).toEqual(mockUser);
        expect(mockUserRepository.findById).toHaveBeenCalledWith(1);
    });
});
```

### 69. What is test coverage and how do you measure it?

**Answer:**
Test coverage measures how much of your code is tested. It can be measured using:
- Istanbul/nyc
- Jest coverage
- Custom coverage tools

**Example using Jest:**
```javascript
// jest.config.js
module.exports = {
    collectCoverage: true,
    coverageThreshold: {
        global: {
            branches: 80,
            functions: 80,
            lines: 80,
            statements: 80
        }
    }
};

// Example test with coverage
describe('Math operations', () => {
    test('add function', () => {
        expect(add(2, 3)).toBe(5);
    });

    test('subtract function', () => {
        expect(subtract(5, 3)).toBe(2);
    });
});
```

### 70. How do you handle asynchronous testing?

**Answer:**
Asynchronous testing can be handled using:
- async/await
- Promises
- Callbacks
- Jest's done callback

**Example:**
```javascript
// Using async/await
describe('Async operations', () => {
    test('should fetch user data', async () => {
        const user = await fetchUser(1);
        expect(user.name).toBe('John');
    });

    test('should handle errors', async () => {
        await expect(fetchUser(-1)).rejects.toThrow('User not found');
    });
});

// Using done callback
test('should complete async operation', done => {
    fetchUser(1, (err, user) => {
        expect(err).toBeNull();
        expect(user.name).toBe('John');
        done();
    });
});

// Using promises
test('should resolve promise', () => {
    return fetchUser(1).then(user => {
        expect(user.name).toBe('John');
    });
});
```

## Security

### 71. What are the common security vulnerabilities in Node.js applications?

**Answer:**
Common vulnerabilities include:
- SQL Injection
- XSS (Cross-Site Scripting)
- CSRF (Cross-Site Request Forgery)
- Insecure Dependencies
- Sensitive Data Exposure

**Example of preventing SQL injection:**
```javascript
// Bad: Vulnerable to SQL injection
const query = `SELECT * FROM users WHERE username = '${username}'`;

// Good: Using parameterized queries
const query = 'SELECT * FROM users WHERE username = ?';
const result = await db.query(query, [username]);

// Good: Using ORM
const user = await User.findOne({ username });
```

### 72. How do you prevent SQL injection?

**Answer:**
SQL injection can be prevented by:
- Using parameterized queries
- Using ORMs
- Input validation
- Escaping user input

**Example:**
```javascript
const mysql = require('mysql2/promise');

async function getUser(username) {
    const connection = await mysql.createConnection({
        host: 'localhost',
        user: 'root',
        database: 'mydb'
    });

    // Bad: Vulnerable to SQL injection
    // const query = `SELECT * FROM users WHERE username = '${username}'`;

    // Good: Using parameterized queries
    const query = 'SELECT * FROM users WHERE username = ?';
    const [rows] = await connection.execute(query, [username]);
    return rows[0];
}

// Using Mongoose (ORM)
const User = require('./models/user');

async function getUser(username) {
    return await User.findOne({ username });
}
```

### 73. What is XSS and how do you prevent it?

**Answer:**
XSS (Cross-Site Scripting) is a vulnerability where attackers inject malicious scripts. Prevention methods:
- Input sanitization
- Output encoding
- Content Security Policy
- Using security headers

**Example:**
```javascript
const express = require('express');
const helmet = require('helmet');
const xss = require('xss');
const app = express();

// Set security headers
app.use(helmet());

// Sanitize input
app.post('/comment', (req, res) => {
    const sanitizedComment = xss(req.body.comment);
    // Store sanitized comment
});

// Encode output
app.get('/user/:id', (req, res) => {
    const user = getUser(req.params.id);
    res.send(`
        <div>
            <h1>${encodeHTML(user.name)}</h1>
            <p>${encodeHTML(user.bio)}</p>
        </div>
    `);
});

function encodeHTML(str) {
    return str
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#039;');
}
```

### 74. How do you implement rate limiting?

**Answer:**
Rate limiting can be implemented using:
- Express-rate-limit
- Redis-based rate limiting
- Custom middleware

**Example:**
```javascript
const express = require('express');
const rateLimit = require('express-rate-limit');
const RedisStore = require('rate-limit-redis');
const redis = require('redis');

const app = express();

// Basic rate limiting
const limiter = rateLimit({
    windowMs: 15 * 60 * 1000, // 15 minutes
    max: 100 // limit each IP to 100 requests per windowMs
});

// Redis-based rate limiting
const redisClient = redis.createClient();
const redisLimiter = rateLimit({
    store: new RedisStore({
        client: redisClient,
        prefix: 'rate-limit:'
    }),
    windowMs: 15 * 60 * 1000,
    max: 100
});

// Apply to all requests
app.use(limiter);

// Apply to specific route
app.use('/api/', redisLimiter);
```

### 75. What is CSRF and how do you prevent it?

**Answer:**
CSRF (Cross-Site Request Forgery) is an attack where malicious sites make requests to your site. Prevention methods:
- CSRF tokens
- SameSite cookies
- Custom headers
- Double submit cookies

**Example:**
```javascript
const express = require('express');
const csrf = require('csurf');
const cookieParser = require('cookie-parser');
const app = express();

// Setup CSRF protection
app.use(cookieParser());
app.use(csrf({ cookie: true }));

// Add CSRF token to all responses
app.use((req, res, next) => {
    res.cookie('XSRF-TOKEN', req.csrfToken());
    next();
});

// Protected route
app.post('/api/transfer', (req, res) => {
    // CSRF token is automatically validated
    // Process the transfer
});

// Error handling
app.use((err, req, res, next) => {
    if (err.code === 'EBADCSRFTOKEN') {
        res.status(403).send('Invalid CSRF token');
    } else {
        next(err);
    }
});
```

## Performance and Optimization

### 76. How do you handle password hashing?

**Answer:**
Password hashing should be done using:
- bcrypt
- Argon2
- scrypt
- Never store plain text passwords

**Example:**
```javascript
const bcrypt = require('bcrypt');

async function hashPassword(password) {
    const saltRounds = 10;
    const hash = await bcrypt.hash(password, saltRounds);
    return hash;
}

async function verifyPassword(password, hash) {
    return await bcrypt.compare(password, hash);
}

// Usage in user registration
async function registerUser(username, password) {
    const hashedPassword = await hashPassword(password);
    await User.create({
        username,
        password: hashedPassword
    });
}

// Usage in login
async function loginUser(username, password) {
    const user = await User.findOne({ username });
    if (!user) throw new Error('User not found');

    const isValid = await verifyPassword(password, user.password);
    if (!isValid) throw new Error('Invalid password');

    return user;
}
```

### 77. What is the purpose of helmet.js?

**Answer:**
Helmet.js helps secure Express apps by setting various HTTP headers:
- Content Security Policy
- X-Frame-Options
- X-XSS-Protection
- X-Content-Type-Options
- Strict-Transport-Security

**Example:**
```javascript
const express = require('express');
const helmet = require('helmet');
const app = express();

// Use all helmet protections
app.use(helmet());

// Or configure specific protections
app.use(helmet({
    contentSecurityPolicy: {
        directives: {
            defaultSrc: ["'self'"],
            scriptSrc: ["'self'", "'unsafe-inline'"],
            styleSrc: ["'self'", "'unsafe-inline'"],
            imgSrc: ["'self'", "data:", "https:"]
        }
    }
}));
```

### 78. How do you implement input validation?

**Answer:**
Input validation can be implemented using:
- Joi
- express-validator
- Custom validation middleware
- Schema validation

**Example:**
```javascript
const express = require('express');
const { body, validationResult } = require('express-validator');
const app = express();

app.use(express.json());

// Validation middleware
const validateUser = [
    body('email').isEmail().normalizeEmail(),
    body('password').isLength({ min: 6 }),
    body('age').isInt({ min: 0, max: 120 }),
    body('name').trim().notEmpty()
];

// Route with validation
app.post('/users', validateUser, (req, res) => {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
        return res.status(400).json({ errors: errors.array() });
    }

    // Process valid input
    createUser(req.body);
    res.status(201).json({ message: 'User created' });
});
```

### 79. What is the difference between authentication and authorization?

**Answer:**
- Authentication: Verifies user identity
- Authorization: Determines user permissions

**Example:**
```javascript
const express = require('express');
const jwt = require('jsonwebtoken');
const app = express();

// Authentication middleware
const authenticate = (req, res, next) => {
    const token = req.headers.authorization;
    if (!token) {
        return res.status(401).json({ message: 'No token provided' });
    }

    try {
        const decoded = jwt.verify(token, 'secret');
        req.user = decoded;
        next();
    } catch (err) {
        res.status(401).json({ message: 'Invalid token' });
    }
};

// Authorization middleware
const authorize = (roles) => {
    return (req, res, next) => {
        if (!roles.includes(req.user.role)) {
            return res.status(403).json({ message: 'Unauthorized' });
        }
        next();
    };
};

// Protected route with both auth
app.get('/admin', 
    authenticate,
    authorize(['admin']),
    (req, res) => {
        res.json({ message: 'Admin access granted' });
    }
);
```

### 80. How do you secure API endpoints?

**Answer:**
API endpoints can be secured using:
- Authentication
- Rate limiting
- Input validation
- HTTPS
- Security headers

**Example:**
```javascript
const express = require('express');
const helmet = require('helmet');
const rateLimit = require('express-rate-limit');
const app = express();

// Security headers
app.use(helmet());

// Rate limiting
const limiter = rateLimit({
    windowMs: 15 * 60 * 1000,
    max: 100
});
app.use('/api/', limiter);

// Authentication middleware
const authenticate = (req, res, next) => {
    const token = req.headers.authorization;
    if (!token) {
        return res.status(401).json({ message: 'No token provided' });
    }
    // Verify token
    next();
};

// Secure API endpoint
app.post('/api/data',
    authenticate,
    validateInput,
    async (req, res) => {
        try {
            const data = await processData(req.body);
            res.json(data);
        } catch (error) {
            res.status(500).json({ message: 'Internal server error' });
        }
    }
);
```

## Deployment and DevOps

### 81. How do you deploy Node.js applications?

**Answer:**
Node.js applications can be deployed using:
- Traditional servers
- Cloud platforms
- Containers
- Serverless platforms

**Example:**
```javascript
// Dockerfile
FROM node:16-alpine
WORKDIR /app
COPY package*.json ./
RUN npm install
COPY . .
EXPOSE 3000
CMD ["npm", "start"]

// docker-compose.yml
version: '3'
services:
  app:
    build: .
    ports:
      - "3000:3000"
    environment:
      - NODE_ENV=production
    restart: always
```

### 82. What is Docker and how do you use it with Node.js?

**Answer:**
Docker is a containerization platform that:
- Packages applications and dependencies
- Ensures consistent environments
- Simplifies deployment
- Improves scalability

**Example:**
```dockerfile
# Dockerfile
FROM node:16-alpine

# Set working directory
WORKDIR /app

# Copy package files
COPY package*.json ./

# Install dependencies
RUN npm install

# Copy application code
COPY . .

# Expose port
EXPOSE 3000

# Start application
CMD ["npm", "start"]

# Usage:
# docker build -t myapp .
# docker run -p 3000:3000 myapp
```

### 83. How do you implement CI/CD for Node.js applications?

**Answer:**
CI/CD can be implemented using:
- GitHub Actions
- Jenkins
- GitLab CI
- CircleCI

**Example using GitHub Actions:**
```yaml
# .github/workflows/ci.yml
name: CI/CD

on:
  push:
    branches: [ main ]

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v2
    
    - name: Setup Node.js
      uses: actions/setup-node@v2
      with:
        node-version: '16'
        
    - name: Install dependencies
      run: npm install
      
    - name: Run tests
      run: npm test
      
    - name: Build
      run: npm run build
      
    - name: Deploy
      run: |
        # Deployment steps
```

### 84. What is the purpose of environment variables?

**Answer:**
Environment variables:
- Store configuration
- Keep secrets secure
- Enable different environments
- Follow 12-factor app principles

**Example:**
```javascript
require('dotenv').config();

const config = {
    port: process.env.PORT || 3000,
    database: {
        url: process.env.DATABASE_URL,
        username: process.env.DB_USERNAME,
        password: process.env.DB_PASSWORD
    },
    jwt: {
        secret: process.env.JWT_SECRET,
        expiresIn: process.env.JWT_EXPIRES_IN
    }
};

// .env file
/*
PORT=3000
DATABASE_URL=mongodb://localhost:27017/mydb
DB_USERNAME=admin
DB_PASSWORD=secret
JWT_SECRET=your-secret-key
JWT_EXPIRES_IN=1h
*/
```

### 85. How do you handle logging in production?

**Answer:**
Production logging can be handled using:
- Winston
- Bunyan
- Morgan
- ELK Stack

**Example:**
```javascript
const winston = require('winston');
const { format } = winston;

const logger = winston.createLogger({
    level: 'info',
    format: format.combine(
        format.timestamp(),
        format.json()
    ),
    transports: [
        new winston.transports.File({ 
            filename: 'error.log', 
            level: 'error' 
        }),
        new winston.transports.File({ 
            filename: 'combined.log' 
        })
    ]
});

if (process.env.NODE_ENV !== 'production') {
    logger.add(new winston.transports.Console({
        format: format.simple()
    }));
}

// Usage
logger.info('User logged in', { userId: 123 });
logger.error('Database error', { error: err });
```

### 86. What is the difference between development and production environments?

**Answer:**
Development:
- Debugging enabled
- Detailed error messages
- Hot reloading
- Local database

Production:
- Optimized performance
- Minimal error details
- Caching enabled
- Production database

**Example:**
```javascript
const express = require('express');
const app = express();

if (process.env.NODE_ENV === 'development') {
    // Development settings
    app.use(require('morgan')('dev'));
    app.use(require('cors')());
    app.use(express.static('public'));
} else {
    // Production settings
    app.use(helmet());
    app.use(compression());
    app.use(rateLimit({
        windowMs: 15 * 60 * 1000,
        max: 100
    }));
}

// Error handling
app.use((err, req, res, next) => {
    if (process.env.NODE_ENV === 'development') {
        res.status(500).json({
            error: err.message,
            stack: err.stack
        });
    } else {
        res.status(500).json({
            error: 'Internal server error'
        });
    }
});
```

### 87. How do you monitor Node.js applications?

**Answer:**
Node.js applications can be monitored using:
- PM2
- New Relic
- Datadog
- Custom monitoring

**Example:**
```javascript
const prometheus = require('prom-client');
const express = require('express');
const app = express();

// Create metrics
const httpRequestDuration = new prometheus.Histogram({
    name: 'http_request_duration_seconds',
    help: 'Duration of HTTP requests in seconds',
    labelNames: ['method', 'route', 'status_code']
});

// Monitoring middleware
app.use((req, res, next) => {
    const start = Date.now();
    res.on('finish', () => {
        const duration = Date.now() - start;
        httpRequestDuration
            .labels(req.method, req.route?.path || 'unknown', res.statusCode)
            .observe(duration / 1000);
    });
    next();
});

// Expose metrics endpoint
app.get('/metrics', async (req, res) => {
    res.set('Content-Type', prometheus.register.contentType);
    res.end(await prometheus.register.metrics());
});
```

### 88. What is the purpose of process managers?

**Answer:**
Process managers:
- Keep applications running
- Handle crashes
- Manage multiple processes
- Provide monitoring

**Example using PM2:**
```javascript
// ecosystem.config.js
module.exports = {
    apps: [{
        name: 'my-app',
        script: 'app.js',
        instances: 'max',
        exec_mode: 'cluster',
        autorestart: true,
        watch: false,
        max_memory_restart: '1G',
        env: {
            NODE_ENV: 'development'
        },
        env_production: {
            NODE_ENV: 'production'
        }
    }]
};

// Usage:
// pm2 start ecosystem.config.js
// pm2 monit
// pm2 logs
// pm2 reload all
```

### 89. How do you handle zero-downtime deployments?

**Answer:**
Zero-downtime deployments can be achieved using:
- Blue-green deployment
- Rolling updates
- Load balancers
- Health checks

**Example:**
```javascript
// Health check endpoint
app.get('/health', (req, res) => {
    res.status(200).json({ status: 'healthy' });
});

// Nginx configuration for blue-green deployment
/*
upstream blue {
    server 192.168.1.1:3000;
}

upstream green {
    server 192.168.1.2:3000;
}

server {
    listen 80;
    server_name example.com;

    location / {
        proxy_pass http://blue;
        health_check interval=5s fails=3 passes=2;
    }
}
*/
```

### 90. What is the difference between staging and production environments?

**Answer:**
Staging:
- Mirrors production
- Used for testing
- Contains production-like data
- Allows safe testing

Production:
- Live environment
- Real user data
- Optimized performance
- Strict security

**Example:**
```javascript
const config = {
    development: {
        database: 'mongodb://localhost:27017/dev',
        logging: true,
        debug: true
    },
    staging: {
        database: 'mongodb://staging:27017/staging',
        logging: true,
        debug: false
    },
    production: {
        database: 'mongodb://prod:27017/prod',
        logging: false,
        debug: false
    }
};

const env = process.env.NODE_ENV || 'development';
module.exports = config[env];
```

## Performance and Optimization

### 91. How do you optimize Node.js applications?

**Answer:**
Node.js applications can be optimized by:
- Using clustering
- Implementing caching
- Optimizing database queries
- Using compression
- Implementing load balancing

**Example:**
```javascript
const cluster = require('cluster');
const numCPUs = require('os').cpus().length;
const express = require('express');
const compression = require('compression');
const app = express();

if (cluster.isMaster) {
    // Fork workers
    for (let i = 0; i < numCPUs; i++) {
        cluster.fork();
    }
} else {
    // Worker process
    app.use(compression());
    
    // Implement caching
    const cache = new Map();
    app.get('/api/data', (req, res) => {
        const key = req.query.key;
        if (cache.has(key)) {
            return res.json(cache.get(key));
        }
        // Fetch and cache data
    });

    app.listen(3000);
}
```

### 92. What is clustering in Node.js?

**Answer:**
Clustering allows Node.js to create multiple worker processes to handle requests, utilizing multiple CPU cores.

**Example:**
```javascript
const cluster = require('cluster');
const numCPUs = require('os').cpus().length;
const express = require('express');

if (cluster.isMaster) {
    console.log(`Master ${process.pid} is running`);

    // Fork workers
    for (let i = 0; i < numCPUs; i++) {
        cluster.fork();
    }

    cluster.on('exit', (worker, code, signal) => {
        console.log(`Worker ${worker.process.pid} died`);
        // Replace the dead worker
        cluster.fork();
    });
} else {
    // Workers share the HTTP server
    const app = express();
    app.get('/', (req, res) => {
        res.send(`Worker ${process.pid} handled request`);
    });

    app.listen(3000);
    console.log(`Worker ${process.pid} started`);
}
```

### 93. How do you handle memory leaks?

**Answer:**
Memory leaks can be handled by:
- Using proper garbage collection
- Monitoring memory usage
- Identifying and fixing leaks
- Using memory profiling tools

**Example:**
```javascript
const heapdump = require('heapdump');
const used = process.memoryUsage();

// Monitor memory usage
setInterval(() => {
    const current = process.memoryUsage();
    console.log({
        rss: `${Math.round(current.rss / 1024 / 1024)}MB`,
        heapTotal: `${Math.round(current.heapTotal / 1024 / 1024)}MB`,
        heapUsed: `${Math.round(current.heapUsed / 1024 / 1024)}MB`
    });
}, 5000);

// Take heap snapshot on memory warning
process.on('warning', (warning) => {
    if (warning.name === 'HeapSizeLimit') {
        heapdump.writeSnapshot(`./heap-${Date.now()}.heapsnapshot`);
    }
});

// Proper cleanup
class Resource {
    constructor() {
        this.data = new Map();
    }

    cleanup() {
        this.data.clear();
    }
}
```

### 94. What is the purpose of PM2?

**Answer:**
PM2 is a process manager for Node.js applications that provides:
- Process management
- Load balancing
- Auto-restart
- Monitoring
- Log management

**Example:**
```javascript
// ecosystem.config.js
module.exports = {
    apps: [{
        name: 'my-app',
        script: 'app.js',
        instances: 'max',
        exec_mode: 'cluster',
        autorestart: true,
        watch: false,
        max_memory_restart: '1G',
        env: {
            NODE_ENV: 'development'
        },
        env_production: {
            NODE_ENV: 'production'
        }
    }]
};

// Usage
// pm2 start ecosystem.config.js
// pm2 monit
// pm2 logs
// pm2 reload all
```

### 95. How do you implement load balancing?

**Answer:**
Load balancing can be implemented using:
- Nginx
- HAProxy
- PM2
- Custom load balancer

**Example using Nginx:**
```nginx
# nginx.conf
upstream nodejs_backend {
    server 127.0.0.1:3000;
    server 127.0.0.1:3001;
    server 127.0.0.1:3002;
    server 127.0.0.1:3003;
}

server {
    listen 80;
    server_name example.com;

    location / {
        proxy_pass http://nodejs_backend;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_cache_bypass $http_upgrade;
    }
}
```

### 96. What is the difference between clustering and load balancing?

**Answer:**
Clustering:
- Runs multiple instances on same machine
- Uses Node.js cluster module
- Shares memory space
- Good for CPU-intensive tasks

Load Balancing:
- Distributes traffic across multiple servers
- Uses external tools (Nginx, HAProxy)
- Separate memory spaces
- Good for high availability

**Example:**
```javascript
// Clustering
const cluster = require('cluster');
const numCPUs = require('os').cpus().length;

if (cluster.isMaster) {
    for (let i = 0; i < numCPUs; i++) {
        cluster.fork();
    }
} else {
    // Worker process
    const app = express();
    app.listen(3000);
}

// Load Balancing (Nginx config)
/*
upstream backend {
    server 192.168.1.1:3000;
    server 192.168.1.2:3000;
    server 192.168.1.3:3000;
}
*/
```

### 97. How do you optimize database queries?

**Answer:**
Database queries can be optimized by:
- Using indexes
- Implementing caching
- Optimizing query structure
- Using connection pooling
- Implementing pagination

**Example:**
```javascript
const mongoose = require('mongoose');

// Define indexes
const userSchema = new mongoose.Schema({
    email: { type: String, index: true },
    name: String,
    age: Number
});

// Compound index
userSchema.index({ name: 1, age: -1 });

// Optimized query with pagination
async function getUsers(page = 1, limit = 10) {
    const skip = (page - 1) * limit;
    
    return await User.find()
        .select('name email') // Select only needed fields
        .sort({ createdAt: -1 })
        .skip(skip)
        .limit(limit)
        .lean(); // Convert to plain objects
}

// Using connection pooling
mongoose.connect('mongodb://localhost/db', {
    poolSize: 10,
    serverSelectionTimeoutMS: 5000,
    socketTimeoutMS: 45000
});
```

### 98. What is the purpose of compression middleware?

**Answer:**
Compression middleware reduces response size by compressing data before sending it to the client.

**Example:**
```javascript
const express = require('express');
const compression = require('compression');
const app = express();

// Enable compression for all routes
app.use(compression());

// Or configure compression
app.use(compression({
    filter: (req, res) => {
        if (req.headers['x-no-compression']) {
            return false;
        }
        return compression.filter(req, res);
    },
    level: 6, // Compression level (0-9)
    threshold: 1024 // Only compress responses larger than 1kb
}));

app.get('/api/data', (req, res) => {
    res.json(largeData); // Will be compressed
});
```

### 99. How do you implement caching strategies?

**Answer:**
Caching strategies can be implemented using:
- In-memory caching
- Redis
- Browser caching
- CDN caching

**Example:**
```javascript
const express = require('express');
const redis = require('redis');
const app = express();

const client = redis.createClient();

// Cache middleware
const cache = (duration) => {
    return async (req, res, next) => {
        const key = `cache:${req.originalUrl}`;
        
        try {
            const cachedResponse = await client.get(key);
            if (cachedResponse) {
                return res.json(JSON.parse(cachedResponse));
            }

            res.sendResponse = res.json;
            res.json = (body) => {
                client.setex(key, duration, JSON.stringify(body));
                res.sendResponse(body);
            };
            next();
        } catch (error) {
            next();
        }
    };
};

// Use cache middleware
app.get('/api/data', cache(300), (req, res) => {
    // Response will be cached for 5 minutes
    res.json({ data: 'some data' });
});
```

### 100. What is the difference between horizontal and vertical scaling?

**Answer:**
Horizontal scaling:
- Adds more machines
- Better for high availability
- More complex to implement
- Better for distributed systems

Vertical scaling:
- Adds more resources to existing machine
- Simpler to implement
- Limited by hardware
- Better for single applications

**Example:**
```javascript
// Horizontal scaling (multiple servers)
const servers = [
    'http://server1:3000',
    'http://server2:3000',
    'http://server3:3000'
];

// Load balancer configuration
const loadBalancer = {
    getServer() {
        return servers[Math.floor(Math.random() * servers.length)];
    }
};

// Vertical scaling (single server)
const app = express();
app.listen(3000, () => {
    console.log('Server running with 16GB RAM and 8 CPU cores');
});
``` 