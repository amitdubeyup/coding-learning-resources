# Node.js Interview Questions and Answers (1-50)

## Core Concepts and Fundamentals

### 1. What is Node.js and what are its key features?

**Answer:**
Node.js is a JavaScript runtime environment built on Chrome's V8 JavaScript engine. It allows developers to run JavaScript code on the server-side.

Key features:
- Event-driven, non-blocking I/O model
- Single-threaded but highly scalable
- Cross-platform compatibility
- Rich ecosystem of packages (npm)
- Built-in support for JSON
- Excellent for real-time applications

**Example:**
```javascript
// Simple HTTP server
const http = require('http');

const server = http.createServer((req, res) => {
    res.writeHead(200, {'Content-Type': 'text/plain'});
    res.end('Hello World\n');
});

server.listen(3000, () => {
    console.log('Server running at http://localhost:3000/');
});
```

### 2. Explain the event-driven architecture of Node.js.

**Answer:**
Node.js uses an event-driven architecture where everything is an event. The main event loop listens for events and triggers callback functions when events occur.

Key components:
- Event Emitter
- Event Loop
- Callback Queue
- Event Queue

**Example:**
```javascript
const EventEmitter = require('events');

class OrderProcessor extends EventEmitter {
    processOrder(order) {
        console.log('Processing order:', order);
        this.emit('orderProcessed', order);
    }
}

const processor = new OrderProcessor();

processor.on('orderProcessed', (order) => {
    console.log('Order processed successfully:', order);
});

processor.processOrder({ id: 1, items: ['item1', 'item2'] });
```

### 3. What is the difference between Node.js and traditional web servers?

**Answer:**
Traditional web servers (Apache, Nginx):
- Multi-threaded
- Blocking I/O
- Each request creates a new thread
- Better for CPU-intensive tasks

Node.js:
- Single-threaded
- Non-blocking I/O
- Event-driven
- Better for I/O-intensive tasks
- Handles concurrent connections efficiently

**Example:**
```javascript
// Traditional server (pseudo-code)
// Each request creates a new thread
for each request:
    create new thread
    handle request
    close thread

// Node.js server
const http = require('http');

const server = http.createServer((req, res) => {
    // Single thread handles all requests
    // Non-blocking I/O
    fs.readFile('file.txt', (err, data) => {
        res.end(data);
    });
});
```

### 4. What is the V8 engine and how does Node.js use it?

**Answer:**
V8 is Google's open-source JavaScript engine that:
- Compiles JavaScript to machine code
- Handles memory management
- Optimizes code execution
- Provides garbage collection

Node.js uses V8 to:
- Execute JavaScript code
- Provide performance optimizations
- Handle memory management
- Enable modern JavaScript features

**Example:**
```javascript
// V8 optimizations in action
function calculateSum(n) {
    let sum = 0;
    for (let i = 0; i < n; i++) {
        sum += i;
    }
    return sum;
}

// V8 will optimize this function after multiple calls
console.log(calculateSum(1000000));
```

### 5. Explain the concept of non-blocking I/O in Node.js.

**Answer:**
Non-blocking I/O means that Node.js doesn't wait for I/O operations to complete before moving to the next task. Instead, it uses callbacks, promises, or async/await to handle the results when they're ready.

**Example:**
```javascript
// Blocking I/O (synchronous)
const data = fs.readFileSync('file.txt');
console.log(data);

// Non-blocking I/O (asynchronous)
fs.readFile('file.txt', (err, data) => {
    if (err) throw err;
    console.log(data);
});
console.log('This runs before file is read');
```

### 6. What is the Node.js event loop and how does it work?

**Answer:**
The event loop is a mechanism that allows Node.js to perform non-blocking I/O operations despite JavaScript being single-threaded. It works in the following phases:

1. Timers
2. Pending callbacks
3. Idle, prepare
4. Poll
5. Check
6. Close callbacks

**Example:**
```javascript
console.log('Start');

setTimeout(() => {
    console.log('Timer 1');
}, 0);

setImmediate(() => {
    console.log('Immediate 1');
});

process.nextTick(() => {
    console.log('Next tick 1');
});

console.log('End');

// Output:
// Start
// End
// Next tick 1
// Timer 1
// Immediate 1
```

### 7. What are the different phases of the Node.js event loop?

**Answer:**
The Node.js event loop has six phases:

1. **Timers**: Executes callbacks scheduled by setTimeout() and setInterval()
2. **Pending callbacks**: Executes I/O callbacks deferred to the next loop iteration
3. **Idle, prepare**: Used internally by Node.js
4. **Poll**: Retrieves new I/O events and executes I/O related callbacks
5. **Check**: Executes setImmediate() callbacks
6. **Close callbacks**: Executes close event callbacks

**Example:**
```javascript
console.log('Start');

// Phase 1: Timers
setTimeout(() => {
    console.log('Timer phase');
}, 0);

// Phase 5: Check
setImmediate(() => {
    console.log('Check phase');
});

// Microtask queue (not part of event loop phases)
Promise.resolve().then(() => {
    console.log('Promise microtask');
});

console.log('End');
```

### 8. What is the purpose of the global object in Node.js?

**Answer:**
The global object in Node.js is similar to the window object in browsers. It provides access to:
- Global variables and functions
- Built-in modules
- Process information
- Environment variables

**Example:**
```javascript
// Global variables
global.myVariable = 'Hello';

// Built-in modules
const http = global.require('http');

// Process information
console.log(global.process.version);

// Environment variables
console.log(global.process.env.NODE_ENV);
```

### 9. How does Node.js handle errors?

**Answer:**
Node.js handles errors through:
- Try-catch blocks
- Error-first callbacks
- Promise rejections
- Event emitters
- Global error handlers

**Example:**
```javascript
// Try-catch
try {
    throw new Error('Something went wrong');
} catch (error) {
    console.error('Caught error:', error);
}

// Error-first callback
fs.readFile('nonexistent.txt', (err, data) => {
    if (err) {
        console.error('Error reading file:', err);
        return;
    }
    console.log(data);
});

// Promise rejection
Promise.reject(new Error('Promise error'))
    .catch(error => console.error('Caught promise error:', error));

// Global error handler
process.on('uncaughtException', (error) => {
    console.error('Uncaught exception:', error);
    process.exit(1);
});
```

### 10. What is the difference between process.nextTick() and setImmediate()?

**Answer:**
- `process.nextTick()`: Executes callback before the next event loop phase
- `setImmediate()`: Executes callback in the Check phase of the next event loop iteration

**Example:**
```javascript
console.log('Start');

setImmediate(() => {
    console.log('setImmediate');
});

process.nextTick(() => {
    console.log('nextTick');
});

console.log('End');

// Output:
// Start
// End
// nextTick
// setImmediate
```

## Modules and Packages

### 11. What is the difference between module.exports and exports?

**Answer:**
- `module.exports` is the actual object that gets exported
- `exports` is a reference to `module.exports`
- You can't reassign `exports` directly

**Example:**
```javascript
// math.js
// This works
module.exports = {
    add: (a, b) => a + b,
    subtract: (a, b) => a - b
};

// This also works
exports.add = (a, b) => a + b;
exports.subtract = (a, b) => a - b;

// This doesn't work
exports = {
    add: (a, b) => a + b
};
```

### 12. Explain the CommonJS module system in Node.js.

**Answer:**
CommonJS is a module system that allows you to:
- Split code into separate files
- Share code between files
- Manage dependencies
- Encapsulate code

**Example:**
```javascript
// math.js
const add = (a, b) => a + b;
const subtract = (a, b) => a - b;

module.exports = {
    add,
    subtract
};

// app.js
const math = require('./math');

console.log(math.add(5, 3));      // 8
console.log(math.subtract(5, 3)); // 2
```

### 13. How do you create and use custom modules in Node.js?

**Answer:**
To create a custom module:
1. Create a new file
2. Define your functions/objects
3. Export them using module.exports
4. Import them using require()

**Example:**
```javascript
// userModule.js
class User {
    constructor(name) {
        this.name = name;
    }

    greet() {
        return `Hello, ${this.name}!`;
    }
}

module.exports = User;

// app.js
const User = require('./userModule');

const user = new User('John');
console.log(user.greet()); // Hello, John!
```

### 14. What is the purpose of package.json?

**Answer:**
package.json is a manifest file that:
- Lists project dependencies
- Defines project metadata
- Contains scripts for running tasks
- Specifies project configuration

**Example:**
```json
{
  "name": "my-project",
  "version": "1.0.0",
  "description": "A sample project",
  "main": "index.js",
  "scripts": {
    "start": "node index.js",
    "test": "jest"
  },
  "dependencies": {
    "express": "^4.17.1",
    "mongoose": "^6.0.0"
  },
  "devDependencies": {
    "jest": "^27.0.0"
  }
}
```

### 15. Explain the difference between dependencies and devDependencies.

**Answer:**
- `dependencies`: Packages required to run the application in production
- `devDependencies`: Packages only needed during development

**Example:**
```json
{
  "dependencies": {
    "express": "^4.17.1",    // Needed in production
    "mongoose": "^6.0.0"     // Needed in production
  },
  "devDependencies": {
    "jest": "^27.0.0",       // Only needed for testing
    "nodemon": "^2.0.0"      // Only needed for development
  }
}
```

### 16. What is npm and how do you use it?

**Answer:**
npm (Node Package Manager) is:
- The default package manager for Node.js
- Used to install and manage dependencies
- Provides a registry of packages
- Includes a CLI for package management

**Example:**
```bash
# Initialize a new project
npm init

# Install a package
npm install express

# Install a dev dependency
npm install --save-dev jest

# Run a script
npm run test

# Update packages
npm update

# Remove a package
npm uninstall express
```

### 17. How do you handle circular dependencies in Node.js?

**Answer:**
Circular dependencies occur when two modules depend on each other. Solutions include:
- Restructuring code
- Using dependency injection
- Moving shared code to a separate module

**Example:**
```javascript
// Bad: Circular dependency
// a.js
const b = require('./b');
module.exports = { b };

// b.js
const a = require('./a');
module.exports = { a };

// Good: Restructured
// shared.js
module.exports = { sharedData: 'data' };

// a.js
const shared = require('./shared');
module.exports = { shared };

// b.js
const shared = require('./shared');
module.exports = { shared };
```

### 18. What is the difference between require() and import?

**Answer:**
- `require()`: CommonJS module system (synchronous)
- `import`: ES Modules (asynchronous, static)

**Example:**
```javascript
// CommonJS (require)
const express = require('express');
const { Router } = require('express');

// ES Modules (import)
import express from 'express';
import { Router } from 'express';

// Dynamic import (ES Modules)
const module = await import('./module.js');
```

### 19. How do you create a private npm package?

**Answer:**
To create a private npm package:
1. Create an npm account
2. Create an organization (paid)
3. Initialize your package
4. Publish with access control

**Example:**
```json
// package.json
{
  "name": "@your-org/package-name",
  "version": "1.0.0",
  "private": true,
  "publishConfig": {
    "access": "restricted"
  }
}
```

```bash
# Login to npm
npm login

# Publish package
npm publish --access restricted
```

### 20. What is the purpose of the node_modules folder?

**Answer:**
The node_modules folder:
- Stores all installed packages
- Contains package dependencies
- Is managed by npm
- Should not be committed to version control

**Example:**
```
project/
├── node_modules/     # Installed packages
│   ├── express/
│   ├── mongoose/
│   └── ...
├── package.json
└── index.js
```

## Asynchronous Programming

### 21. What are callbacks in Node.js?

**Answer:**
Callbacks are functions passed as arguments to other functions, executed after the main function completes.

**Example:**
```javascript
function fetchData(callback) {
    setTimeout(() => {
        const data = { id: 1, name: 'John' };
        callback(null, data);
    }, 1000);
}

fetchData((err, data) => {
    if (err) {
        console.error('Error:', err);
        return;
    }
    console.log('Data:', data);
});
```

### 22. Explain the concept of callback hell and how to avoid it.

**Answer:**
Callback hell occurs when callbacks are nested deeply, making code hard to read and maintain. Solutions include:
- Using promises
- Using async/await
- Using named functions
- Using control flow libraries

**Example:**
```javascript
// Callback hell
fs.readFile('file1.txt', (err, data1) => {
    fs.readFile('file2.txt', (err, data2) => {
        fs.readFile('file3.txt', (err, data3) => {
            console.log(data1, data2, data3);
        });
    });
});

// Using promises
Promise.all([
    fs.promises.readFile('file1.txt'),
    fs.promises.readFile('file2.txt'),
    fs.promises.readFile('file3.txt')
]).then(([data1, data2, data3]) => {
    console.log(data1, data2, data3);
});

// Using async/await
async function readFiles() {
    const [data1, data2, data3] = await Promise.all([
        fs.promises.readFile('file1.txt'),
        fs.promises.readFile('file2.txt'),
        fs.promises.readFile('file3.txt')
    ]);
    console.log(data1, data2, data3);
}
```

### 23. What are Promises in Node.js?

**Answer:**
Promises are objects representing the eventual completion or failure of an asynchronous operation. They have three states:
- Pending
- Fulfilled
- Rejected

**Example:**
```javascript
const promise = new Promise((resolve, reject) => {
    setTimeout(() => {
        const success = true;
        if (success) {
            resolve('Operation successful');
        } else {
            reject('Operation failed');
        }
    }, 1000);
});

promise
    .then(result => console.log(result))
    .catch(error => console.error(error));
```

### 24. How do you handle multiple promises?

**Answer:**
Multiple promises can be handled using:
- Promise.all()
- Promise.race()
- Promise.allSettled()
- Promise.any()

**Example:**
```javascript
const promise1 = Promise.resolve(1);
const promise2 = Promise.resolve(2);
const promise3 = Promise.resolve(3);

// Wait for all promises
Promise.all([promise1, promise2, promise3])
    .then(values => console.log(values)); // [1, 2, 3]

// Wait for first promise to resolve
Promise.race([promise1, promise2, promise3])
    .then(value => console.log(value)); // 1

// Wait for all promises to settle
Promise.allSettled([promise1, promise2, promise3])
    .then(results => console.log(results));
```

### 25. What is async/await and how does it work?

**Answer:**
async/await is syntactic sugar over promises that makes asynchronous code look synchronous. It:
- Uses the async keyword for functions
- Uses the await keyword to wait for promises
- Handles errors with try/catch

**Example:**
```javascript
async function fetchUserData() {
    try {
        const response = await fetch('https://api.example.com/user');
        const user = await response.json();
        return user;
    } catch (error) {
        console.error('Error:', error);
        throw error;
    }
}

// Using the async function
fetchUserData()
    .then(user => console.log(user))
    .catch(error => console.error(error));
```

### 26. Explain the difference between Promise.all() and Promise.race().

**Answer:**
- `Promise.all()`: Waits for all promises to resolve
- `Promise.race()`: Returns the first promise that resolves or rejects

**Example:**
```javascript
const promise1 = new Promise(resolve => setTimeout(() => resolve(1), 1000));
const promise2 = new Promise(resolve => setTimeout(() => resolve(2), 500));
const promise3 = new Promise(resolve => setTimeout(() => resolve(3), 1500));

// Promise.all
Promise.all([promise1, promise2, promise3])
    .then(values => console.log(values)); // [1, 2, 3] after 1.5s

// Promise.race
Promise.race([promise1, promise2, promise3])
    .then(value => console.log(value)); // 2 after 0.5s
```

### 27. How do you handle errors in async/await?

**Answer:**
Errors in async/await can be handled using:
- try/catch blocks
- Promise.catch()
- Error handling middleware

**Example:**
```javascript
// Using try/catch
async function fetchData() {
    try {
        const response = await fetch('https://api.example.com/data');
        const data = await response.json();
        return data;
    } catch (error) {
        console.error('Error:', error);
        throw error;
    }
}

// Using Promise.catch
fetchData()
    .then(data => console.log(data))
    .catch(error => console.error('Error:', error));

// Error handling middleware (Express)
app.use((err, req, res, next) => {
    console.error(err.stack);
    res.status(500).send('Something broke!');
});
```

### 28. What is the purpose of util.promisify()?

**Answer:**
util.promisify() converts callback-based functions to promise-based functions.

**Example:**
```javascript
const util = require('util');
const fs = require('fs');

// Convert fs.readFile to promise-based
const readFilePromise = util.promisify(fs.readFile);

// Using the promisified function
async function readFile() {
    try {
        const data = await readFilePromise('file.txt');
        console.log(data);
    } catch (error) {
        console.error('Error:', error);
    }
}
```

### 29. How do you convert callback-based functions to promises?

**Answer:**
Callback-based functions can be converted to promises using:
- util.promisify()
- Manual promise wrapping
- Promise constructor

**Example:**
```javascript
// Original callback function
function fetchData(callback) {
    setTimeout(() => {
        callback(null, 'Data');
    }, 1000);
}

// Using util.promisify
const util = require('util');
const fetchDataPromise = util.promisify(fetchData);

// Manual promise wrapping
function fetchDataPromise() {
    return new Promise((resolve, reject) => {
        fetchData((err, data) => {
            if (err) reject(err);
            else resolve(data);
        });
    });
}
```

### 30. What is the difference between synchronous and asynchronous code?

**Answer:**
Synchronous code:
- Executes sequentially
- Blocks execution
- Waits for each operation to complete

Asynchronous code:
- Executes non-sequentially
- Doesn't block execution
- Continues execution while waiting for operations

**Example:**
```javascript
// Synchronous
console.log('Start');
const data = fs.readFileSync('file.txt');
console.log(data);
console.log('End');

// Asynchronous
console.log('Start');
fs.readFile('file.txt', (err, data) => {
    console.log(data);
});
console.log('End');

// Output (Synchronous):
// Start
// File contents
// End

// Output (Asynchronous):
// Start
// End
// File contents
```

## File System and Streams

### 31. How do you read and write files in Node.js?

**Answer:**
Files can be read and written using:
- Synchronous methods (readFileSync, writeFileSync)
- Asynchronous methods (readFile, writeFile)
- Streams (createReadStream, createWriteStream)

**Example:**
```javascript
const fs = require('fs');

// Synchronous
const data = fs.readFileSync('input.txt', 'utf8');
fs.writeFileSync('output.txt', data);

// Asynchronous
fs.readFile('input.txt', 'utf8', (err, data) => {
    if (err) throw err;
    fs.writeFile('output.txt', data, err => {
        if (err) throw err;
        console.log('File written successfully');
    });
});

// Using promises
const fsPromises = require('fs').promises;
async function copyFile() {
    const data = await fsPromises.readFile('input.txt', 'utf8');
    await fsPromises.writeFile('output.txt', data);
}
```

### 32. What are streams in Node.js?

**Answer:**
Streams are objects that let you read data from a source or write data to a destination continuously. Types:
- Readable
- Writable
- Duplex
- Transform

**Example:**
```javascript
const fs = require('fs');

// Readable stream
const readableStream = fs.createReadStream('input.txt');

// Writable stream
const writableStream = fs.createWriteStream('output.txt');

// Pipe data from readable to writable
readableStream.pipe(writableStream);

// Handle events
readableStream.on('data', chunk => {
    console.log('Received chunk:', chunk);
});

readableStream.on('end', () => {
    console.log('Finished reading');
});
```

### 33. Explain the different types of streams.

**Answer:**
Node.js has four types of streams:
1. Readable: Used for read operations
2. Writable: Used for write operations
3. Duplex: Used for both read and write operations
4. Transform: A type of duplex stream where the output is computed from input

**Example:**
```javascript
const { Readable, Writable, Duplex, Transform } = require('stream');

// Readable stream
class MyReadable extends Readable {
    _read() {
        this.push('data');
        this.push(null);
    }
}

// Writable stream
class MyWritable extends Writable {
    _write(chunk, encoding, callback) {
        console.log(chunk.toString());
        callback();
    }
}

// Duplex stream
class MyDuplex extends Duplex {
    _read() {
        this.push('data');
        this.push(null);
    }
    _write(chunk, encoding, callback) {
        console.log(chunk.toString());
        callback();
    }
}

// Transform stream
class MyTransform extends Transform {
    _transform(chunk, encoding, callback) {
        this.push(chunk.toString().toUpperCase());
        callback();
    }
}
```

### 34. How do you handle large files in Node.js?

**Answer:**
Large files should be handled using streams to:
- Avoid memory issues
- Process data in chunks
- Improve performance

**Example:**
```javascript
const fs = require('fs');

// Bad: Loading entire file into memory
fs.readFile('large-file.txt', (err, data) => {
    // Memory issues with large files
});

// Good: Using streams
const readStream = fs.createReadStream('large-file.txt');
const writeStream = fs.createWriteStream('output.txt');

readStream.on('data', chunk => {
    // Process chunk
    writeStream.write(chunk);
});

readStream.on('end', () => {
    writeStream.end();
});
```

### 35. What is the purpose of pipe() in streams?

**Answer:**
pipe() is used to:
- Connect readable and writable streams
- Handle backpressure automatically
- Simplify stream handling

**Example:**
```javascript
const fs = require('fs');
const zlib = require('zlib');

// Without pipe
const readStream = fs.createReadStream('input.txt');
const writeStream = fs.createWriteStream('output.txt');

readStream.on('data', chunk => {
    writeStream.write(chunk);
});

// With pipe
fs.createReadStream('input.txt')
    .pipe(zlib.createGzip())
    .pipe(fs.createWriteStream('output.txt.gz'));
```

### 36. How do you create a readable stream?

**Answer:**
Readable streams can be created using:
- Built-in stream classes
- Custom stream classes
- Stream constructors

**Example:**
```javascript
const { Readable } = require('stream');

// Using constructor
const readable = new Readable({
    read() {
        this.push('data');
        this.push(null);
    }
});

// Custom readable stream
class MyReadable extends Readable {
    constructor(options) {
        super(options);
        this.data = ['a', 'b', 'c'];
    }

    _read() {
        if (this.data.length) {
            this.push(this.data.shift());
        } else {
            this.push(null);
        }
    }
}

const myReadable = new MyReadable();
```

### 37. How do you create a writable stream?

**Answer:**
Writable streams can be created using:
- Built-in stream classes
- Custom stream classes
- Stream constructors

**Example:**
```javascript
const { Writable } = require('stream');

// Using constructor
const writable = new Writable({
    write(chunk, encoding, callback) {
        console.log(chunk.toString());
        callback();
    }
});

// Custom writable stream
class MyWritable extends Writable {
    _write(chunk, encoding, callback) {
        console.log(chunk.toString());
        callback();
    }
}

const myWritable = new MyWritable();
```

### 38. What is the difference between fs.readFile and fs.createReadStream?

**Answer:**
- `fs.readFile`: Reads entire file into memory
- `fs.createReadStream`: Reads file in chunks

**Example:**
```javascript
const fs = require('fs');

// fs.readFile - loads entire file into memory
fs.readFile('large-file.txt', (err, data) => {
    if (err) throw err;
    console.log(data);
});

// fs.createReadStream - reads in chunks
const stream = fs.createReadStream('large-file.txt');
stream.on('data', chunk => {
    console.log(chunk);
});
```

### 39. What is the purpose of the path module?

**Answer:**
The path module provides utilities for working with file and directory paths:
- Path manipulation
- Path normalization
- Path joining
- Path parsing

**Example:**
```javascript
const path = require('path');

// Join paths
const fullPath = path.join('/home', 'user', 'file.txt');

// Get file extension
const ext = path.extname('file.txt');

// Get directory name
const dir = path.dirname('/home/user/file.txt');

// Get file name
const filename = path.basename('/home/user/file.txt');

// Resolve path
const absolutePath = path.resolve('file.txt');
```

### 40. How do you handle file uploads in Node.js?

**Answer:**
File uploads can be handled using:
- Multer middleware
- Formidable
- Built-in streams

**Example:**
```javascript
const express = require('express');
const multer = require('multer');
const app = express();

// Configure multer
const storage = multer.diskStorage({
    destination: (req, file, cb) => {
        cb(null, 'uploads/');
    },
    filename: (req, file, cb) => {
        cb(null, Date.now() + '-' + file.originalname);
    }
});

const upload = multer({ storage: storage });

// Handle file upload
app.post('/upload', upload.single('file'), (req, res) => {
    res.send('File uploaded successfully');
});
```

## Web Development

### 41. What is Express.js and what are its features?

**Answer:**
Express.js is a web application framework for Node.js that provides:
- Routing
- Middleware
- Template engines
- Static file serving
- Error handling

**Example:**
```javascript
const express = require('express');
const app = express();

// Middleware
app.use(express.json());

// Routing
app.get('/', (req, res) => {
    res.send('Hello World');
});

// Error handling
app.use((err, req, res, next) => {
    console.error(err.stack);
    res.status(500).send('Something broke!');
});

app.listen(3000);
```

### 42. How do you create a basic Express.js server?

**Answer:**
A basic Express.js server can be created by:
1. Installing Express
2. Creating an app instance
3. Defining routes
4. Starting the server

**Example:**
```javascript
const express = require('express');
const app = express();

// Middleware
app.use(express.json());

// Routes
app.get('/', (req, res) => {
    res.send('Home page');
});

app.get('/about', (req, res) => {
    res.send('About page');
});

// Start server
app.listen(3000, () => {
    console.log('Server running on port 3000');
});
```

### 43. What are middleware functions in Express.js?

**Answer:**
Middleware functions are functions that:
- Have access to request and response objects
- Execute in sequence
- Can modify request and response
- Can end request-response cycle

**Example:**
```javascript
const express = require('express');
const app = express();

// Custom middleware
const logger = (req, res, next) => {
    console.log(`${req.method} ${req.url}`);
    next();
};

// Authentication middleware
const auth = (req, res, next) => {
    if (req.headers.authorization) {
        next();
    } else {
        res.status(401).send('Unauthorized');
    }
};

// Using middleware
app.use(logger);
app.use(auth);

app.get('/', (req, res) => {
    res.send('Hello World');
});
```

### 44. How do you handle routing in Express.js?

**Answer:**
Routing in Express.js can be handled using:
- app.get(), app.post(), etc.
- Router objects
- Route parameters
- Query parameters

**Example:**
```javascript
const express = require('express');
const router = express.Router();

// Basic routes
router.get('/', (req, res) => {
    res.send('Home page');
});

// Route parameters
router.get('/users/:id', (req, res) => {
    res.send(`User ${req.params.id}`);
});

// Query parameters
router.get('/search', (req, res) => {
    res.send(`Search results for: ${req.query.q}`);
});

// Multiple handlers
router.get('/profile',
    (req, res, next) => {
        // Authentication
        next();
    },
    (req, res) => {
        res.send('Profile page');
    }
);

app.use(router);
```

### 45. What is the purpose of app.use() in Express.js?

**Answer:**
app.use() is used to:
- Mount middleware
- Mount routers
- Handle static files
- Set up error handling

**Example:**
```javascript
const express = require('express');
const app = express();

// Mount middleware
app.use(express.json());
app.use(express.urlencoded({ extended: true }));

// Mount static files
app.use(express.static('public'));

// Mount router
app.use('/api', apiRouter);

// Error handling middleware
app.use((err, req, res, next) => {
    console.error(err.stack);
    res.status(500).send('Something broke!');
});
```

### 46. How do you handle CORS in Node.js?

**Answer:**
CORS can be handled using:
- cors middleware
- Custom headers
- Proxy servers

**Example:**
```javascript
const express = require('express');
const cors = require('cors');
const app = express();

// Using cors middleware
app.use(cors());

// Custom CORS headers
app.use((req, res, next) => {
    res.header('Access-Control-Allow-Origin', '*');
    res.header('Access-Control-Allow-Methods', 'GET,PUT,POST,DELETE');
    res.header('Access-Control-Allow-Headers', 'Content-Type');
    next();
});
```

### 47. What is the difference between app.get() and app.post()?

**Answer:**
- `app.get()`: Handles HTTP GET requests
- `app.post()`: Handles HTTP POST requests

**Example:**
```javascript
const express = require('express');
const app = express();

// GET request
app.get('/users', (req, res) => {
    res.send('Get all users');
});

// POST request
app.post('/users', (req, res) => {
    const newUser = req.body;
    res.send('Create new user');
});
```

### 48. How do you implement authentication in Node.js?

**Answer:**
Authentication can be implemented using:
- JWT
- Session-based auth
- OAuth
- Passport.js

**Example:**
```javascript
const express = require('express');
const jwt = require('jsonwebtoken');
const app = express();

// Login route
app.post('/login', (req, res) => {
    const { username, password } = req.body;
    // Verify credentials
    const token = jwt.sign({ username }, 'secret');
    res.json({ token });
});

// Protected route
app.get('/protected', (req, res, next) => {
    const token = req.headers.authorization;
    if (!token) {
        return res.status(401).send('Unauthorized');
    }
    try {
        const decoded = jwt.verify(token, 'secret');
        req.user = decoded;
        next();
    } catch (err) {
        res.status(401).send('Invalid token');
    }
});
```

### 49. What is JWT and how do you use it?

**Answer:**
JWT (JSON Web Token) is a standard for creating access tokens. It consists of:
- Header
- Payload
- Signature

**Example:**
```javascript
const jwt = require('jsonwebtoken');

// Create token
const token = jwt.sign(
    { userId: 123 },
    'secret',
    { expiresIn: '1h' }
);

// Verify token
jwt.verify(token, 'secret', (err, decoded) => {
    if (err) {
        console.error('Invalid token');
    } else {
        console.log(decoded);
    }
});
```

### 50. How do you handle file uploads in Express.js?

**Answer:**
File uploads can be handled using:
- Multer middleware
- Formidable
- Built-in streams

**Example:**
```javascript
const express = require('express');
const multer = require('multer');
const app = express();

// Configure multer
const storage = multer.diskStorage({
    destination: (req, file, cb) => {
        cb(null, 'uploads/');
    },
    filename: (req, file, cb) => {
        cb(null, Date.now() + '-' + file.originalname);
    }
});

const upload = multer({ storage: storage });

// Handle single file upload
app.post('/upload', upload.single('file'), (req, res) => {
    res.send('File uploaded successfully');
});

// Handle multiple file uploads
app.post('/upload-multiple', upload.array('files', 5), (req, res) => {
    res.send('Files uploaded successfully');
});
``` 