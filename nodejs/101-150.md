# Node.js Interview Questions (101-150)

## System Design and Architecture

### 101. How would you design a scalable Node.js application that handles millions of requests?

**Answer:**
To design a scalable Node.js application handling millions of requests, consider these key components:

1. **Load Balancing**
```javascript
// Using Nginx as a load balancer
upstream backend {
    server 127.0.0.1:3000;
    server 127.0.0.1:3001;
    server 127.0.0.1:3002;
}
```

2. **Horizontal Scaling**
```javascript
// Using PM2 for process management
module.exports = {
  apps: [{
    name: "app",
    script: "./app.js",
    instances: "max",
    exec_mode: "cluster"
  }]
}
```

3. **Caching Strategy**
```javascript
// Using Redis for caching
const redis = require('redis');
const client = redis.createClient();

async function getCachedData(key) {
    const cached = await client.get(key);
    if (cached) return JSON.parse(cached);
    // Fetch and cache data
    const data = await fetchData();
    await client.set(key, JSON.stringify(data), 'EX', 3600);
    return data;
}
```

### 102. Explain how you would implement a distributed caching system.

**Answer:**
A distributed caching system can be implemented using Redis Cluster:

```javascript
const Redis = require('ioredis');

// Create a Redis cluster
const cluster = new Redis.Cluster([
    { host: 'redis-1', port: 6379 },
    { host: 'redis-2', port: 6379 },
    { host: 'redis-3', port: 6379 }
]);

// Cache middleware
const cacheMiddleware = async (req, res, next) => {
    const key = `cache:${req.originalUrl}`;
    const cached = await cluster.get(key);
    
    if (cached) {
        return res.json(JSON.parse(cached));
    }
    
    res.sendResponse = res.json;
    res.json = (body) => {
        cluster.set(key, JSON.stringify(body), 'EX', 3600);
        res.sendResponse(body);
    };
    next();
};
```

### 103. How would you design a real-time notification system that can handle 1M+ users?

**Answer:**
A scalable real-time notification system can be built using WebSocket and Redis:

```javascript
const WebSocket = require('ws');
const Redis = require('ioredis');

// WebSocket server
const wss = new WebSocket.Server({ port: 8080 });
const redis = new Redis();

// Handle connections
wss.on('connection', (ws) => {
    ws.on('message', async (message) => {
        const data = JSON.parse(message);
        // Store user connection
        await redis.hset(`user:${data.userId}`, 'ws', ws.id);
    });
});

// Publish notifications
async function publishNotification(userId, notification) {
    const userWs = await redis.hget(`user:${userId}`, 'ws');
    if (userWs) {
        wss.clients.get(userWs).send(JSON.stringify(notification));
    }
}
```

### 104. Design a system for handling file uploads at scale.

**Answer:**
A scalable file upload system using streams and cloud storage:

```javascript
const express = require('express');
const multer = require('multer');
const { Storage } = require('@google-cloud/storage');

const storage = new Storage();
const bucket = storage.bucket('my-bucket');

const upload = multer({
    storage: multer.memoryStorage(),
    limits: {
        fileSize: 5 * 1024 * 1024 // 5MB
    }
});

app.post('/upload', upload.single('file'), async (req, res) => {
    const blob = bucket.file(req.file.originalname);
    const blobStream = blob.createWriteStream();

    blobStream.on('error', (err) => {
        res.status(500).send(err);
    });

    blobStream.on('finish', () => {
        res.status(200).send('Upload complete');
    });

    blobStream.end(req.file.buffer);
});
```

### 105. How would you implement a distributed rate limiting system?

**Answer:**
Using Redis for distributed rate limiting:

```javascript
const Redis = require('ioredis');
const redis = new Redis();

async function rateLimiter(req, res, next) {
    const key = `ratelimit:${req.ip}`;
    const limit = 100; // requests
    const window = 3600; // 1 hour in seconds

    const current = await redis.incr(key);
    if (current === 1) {
        await redis.expire(key, window);
    }

    if (current > limit) {
        return res.status(429).json({
            error: 'Too many requests'
        });
    }

    next();
}
```

### 106. Design a system for handling WebSocket connections at scale.

**Answer:**
Using Socket.IO with Redis adapter for horizontal scaling:

```javascript
const express = require('express');
const app = express();
const server = require('http').createServer(app);
const io = require('socket.io')(server);
const redisAdapter = require('socket.io-redis');

// Configure Redis adapter
io.adapter(redisAdapter({
    host: 'redis',
    port: 6379
}));

// Handle connections
io.on('connection', (socket) => {
    // Join room
    socket.on('join', (room) => {
        socket.join(room);
    });

    // Handle messages
    socket.on('message', (data) => {
        io.to(data.room).emit('message', data);
    });
});

server.listen(3000);
```

### 107. How would you implement a distributed job queue system?

**Answer:**
Using Bull for distributed job processing:

```javascript
const Queue = require('bull');
const emailQueue = new Queue('email', {
    redis: {
        host: 'redis',
        port: 6379
    }
});

// Producer
async function sendEmail(data) {
    await emailQueue.add(data, {
        attempts: 3,
        backoff: {
            type: 'exponential',
            delay: 1000
        }
    });
}

// Consumer
emailQueue.process(async (job) => {
    const { to, subject, body } = job.data;
    // Send email logic
    await sendEmailLogic(to, subject, body);
});
```

### 108. Design a system for handling real-time analytics.

**Answer:**
Using Redis for real-time data aggregation:

```javascript
const Redis = require('ioredis');
const redis = new Redis();

class Analytics {
    async trackEvent(event) {
        const pipeline = redis.pipeline();
        
        // Increment total events
        pipeline.incr('analytics:total');
        
        // Track by event type
        pipeline.incr(`analytics:event:${event.type}`);
        
        // Track by user
        pipeline.incr(`analytics:user:${event.userId}`);
        
        // Store event details
        pipeline.lpush('analytics:events', JSON.stringify(event));
        
        await pipeline.exec();
    }

    async getStats() {
        const [total, events, users] = await Promise.all([
            redis.get('analytics:total'),
            redis.hgetall('analytics:event:*'),
            redis.hgetall('analytics:user:*')
        ]);
        
        return { total, events, users };
    }
}
```

### 109. How would you implement a distributed session management system?

**Answer:**
Using Redis for distributed session storage:

```javascript
const session = require('express-session');
const RedisStore = require('connect-redis')(session);
const Redis = require('ioredis');

const redisClient = new Redis({
    host: 'redis',
    port: 6379
});

app.use(session({
    store: new RedisStore({ client: redisClient }),
    secret: 'your-secret',
    resave: false,
    saveUninitialized: false,
    cookie: {
        secure: true,
        httpOnly: true,
        maxAge: 1000 * 60 * 60 * 24 // 24 hours
    }
}));
```

### 110. Design a system for handling API gateway at scale.

**Answer:**
Using Express Gateway for API management:

```javascript
const gateway = require('express-gateway');

gateway()
    .load(path.join(__dirname, 'config'))
    .run();

// config/gateway.config.yml
http:
  port: 8080
admin:
  port: 9876
  hostname: localhost
apiEndpoints:
  api:
    host: localhost
    paths: '/api/*'
serviceEndpoints:
  users:
    url: 'http://users-service'
  products:
    url: 'http://products-service'
pipelines:
  api:
    apiEndpoints:
      - api
    policies:
      - rate-limit:
          - action:
              max: 100
              windowMs: 60000
      - proxy:
          - action:
              serviceEndpoint: users
              pathRewrite: '^/api/users'
```

### 111. How does the Node.js event loop handle different phases?

**Answer:**
The Node.js event loop has several phases:

```javascript
// Example demonstrating different phases
console.log('1. Start'); // Synchronous code

setTimeout(() => {
    console.log('2. Timer phase');
}, 0);

setImmediate(() => {
    console.log('3. Check phase');
});

process.nextTick(() => {
    console.log('4. Next tick phase');
});

Promise.resolve().then(() => {
    console.log('5. Microtask phase');
});

console.log('6. End'); // Synchronous code
```

### 112. What is the purpose of the Node.js Buffer class?

**Answer:**
The Buffer class is used for handling binary data:

```javascript
// Creating buffers
const buf1 = Buffer.alloc(10); // Creates a buffer of 10 bytes
const buf2 = Buffer.from('Hello'); // Creates a buffer from string
const buf3 = Buffer.from([1, 2, 3]); // Creates a buffer from array

// Reading from buffer
console.log(buf2.toString()); // 'Hello'

// Writing to buffer
buf1.write('Hello');
console.log(buf1.toString()); // 'Hello'

// Buffer operations
const buf4 = Buffer.concat([buf2, buf3]);
console.log(buf4); // <Buffer 48 65 6c 6c 6f 01 02 03>
```

### 113. How does Node.js handle child processes?

**Answer:**
Node.js provides several ways to handle child processes:

```javascript
const { spawn, exec, fork } = require('child_process');

// Using spawn
const ls = spawn('ls', ['-lh', '/usr']);

ls.stdout.on('data', (data) => {
    console.log(`stdout: ${data}`);
});

ls.stderr.on('data', (data) => {
    console.error(`stderr: ${data}`);
});

// Using exec
exec('ls -lh /usr', (error, stdout, stderr) => {
    if (error) {
        console.error(`Error: ${error}`);
        return;
    }
    console.log(`stdout: ${stdout}`);
});

// Using fork
const child = fork('child.js');
child.on('message', (message) => {
    console.log('Message from child:', message);
});
child.send({ hello: 'world' });
```

### 114. Explain the Worker Threads module in Node.js.

**Answer:**
Worker Threads allow running CPU-intensive tasks in parallel:

```javascript
const { Worker, isMainThread, parentPort } = require('worker_threads');

if (isMainThread) {
    // Main thread
    const worker = new Worker(__filename);
    
    worker.on('message', (message) => {
        console.log('From worker:', message);
    });
    
    worker.postMessage('Hello worker!');
} else {
    // Worker thread
    parentPort.on('message', (message) => {
        console.log('From main:', message);
        // Do CPU-intensive work
        const result = heavyComputation();
        parentPort.postMessage(result);
    });
}
```

### 115. How does Node.js handle streams internally?

**Answer:**
Node.js streams are implemented using the Stream class:

```javascript
const { Readable, Writable, Transform } = require('stream');

// Custom readable stream
class MyReadable extends Readable {
    constructor(options) {
        super(options);
        this.data = ['a', 'b', 'c'];
    }

    _read() {
        const chunk = this.data.shift();
        if (chunk) {
            this.push(chunk);
        } else {
            this.push(null);
        }
    }
}

// Custom writable stream
class MyWritable extends Writable {
    _write(chunk, encoding, callback) {
        console.log('Writing:', chunk.toString());
        callback();
    }
}

// Custom transform stream
class MyTransform extends Transform {
    _transform(chunk, encoding, callback) {
        this.push(chunk.toString().toUpperCase());
        callback();
    }
}

// Using the streams
const readable = new MyReadable();
const transform = new MyTransform();
const writable = new MyWritable();

readable.pipe(transform).pipe(writable);
```

### 116. What is the purpose of the Node.js cluster module?

**Answer:**
The cluster module enables load balancing across multiple CPU cores:

```javascript
const cluster = require('cluster');
const http = require('http');
const numCPUs = require('os').cpus().length;

if (cluster.isMaster) {
    console.log(`Master ${process.pid} is running`);

    // Fork workers
    for (let i = 0; i < numCPUs; i++) {
        cluster.fork();
    }

    cluster.on('exit', (worker, code, signal) => {
        console.log(`Worker ${worker.process.pid} died`);
        // Replace the dead worker
        cluster.fork();
    });
} else {
    // Workers can share any TCP connection
    http.createServer((req, res) => {
        res.writeHead(200);
        res.end('Hello World\n');
    }).listen(8000);

    console.log(`Worker ${process.pid} started`);
}
```

### 117. How does Node.js handle errors internally?

**Answer:**
Node.js provides several mechanisms for error handling:

```javascript
// Try-catch for synchronous code
try {
    throw new Error('Something went wrong');
} catch (error) {
    console.error('Caught error:', error);
}

// Error handling in callbacks
fs.readFile('nonexistent.txt', (error, data) => {
    if (error) {
        console.error('Error reading file:', error);
        return;
    }
    console.log(data);
});

// Error handling in promises
async function handleError() {
    try {
        await someAsyncOperation();
    } catch (error) {
        console.error('Async error:', error);
    }
}

// Global error handlers
process.on('uncaughtException', (error) => {
    console.error('Uncaught exception:', error);
    // Perform cleanup
    process.exit(1);
});

process.on('unhandledRejection', (reason, promise) => {
    console.error('Unhandled rejection:', reason);
});
```

### 118. Explain the Node.js module system internals.

**Answer:**
The Node.js module system uses CommonJS:

```javascript
// module.js
const privateVariable = 'private';
const publicVariable = 'public';

function privateFunction() {
    console.log(privateVariable);
}

function publicFunction() {
    console.log(publicVariable);
}

// Exporting
module.exports = {
    publicVariable,
    publicFunction
};

// Importing
const { publicVariable, publicFunction } = require('./module');

// Circular dependencies
// a.js
const b = require('./b');
module.exports = { b };

// b.js
const a = require('./a');
module.exports = { a };
```

### 119. What is the purpose of the Node.js vm module?

**Answer:**
The vm module provides APIs for compiling and running code in a sandbox:

```javascript
const vm = require('vm');

// Running code in a sandbox
const context = {
    console: console,
    x: 10
};

const script = new vm.Script(`
    console.log(x);
    x = 20;
    console.log(x);
`);

const contextifiedSandbox = vm.createContext(context);
script.runInContext(contextifiedSandbox);

// Running code with timeout
const timeoutScript = new vm.Script('while(true) {}');
try {
    timeoutScript.runInNewContext({}, { timeout: 1000 });
} catch (error) {
    console.error('Script timed out');
}
```

### 120. How does Node.js handle memory management?

**Answer:**
Node.js uses V8's garbage collection for memory management:

```javascript
// Memory leak example
class MemoryLeak {
    constructor() {
        this.data = [];
    }

    addData() {
        // Memory leak: array keeps growing
        this.data.push(new Array(1000000).fill('*'));
    }
}

// Proper memory management
class ProperMemory {
    constructor() {
        this.data = [];
        this.maxSize = 1000;
    }

    addData() {
        if (this.data.length >= this.maxSize) {
            this.data.shift(); // Remove old data
        }
        this.data.push(new Array(1000).fill('*'));
    }
}

// Using WeakMap for memory management
const cache = new WeakMap();

function cacheUser(user) {
    cache.set(user, {
        lastAccess: Date.now(),
        data: user.data
    });
}
```

### 121. How do you optimize Node.js application performance?

**Answer:**
Several techniques for optimizing Node.js performance:

```javascript
// 1. Use streams for large files
const fs = require('fs');
const readStream = fs.createReadStream('large-file.txt');
const writeStream = fs.createWriteStream('output.txt');
readStream.pipe(writeStream);

// 2. Implement caching
const NodeCache = require('node-cache');
const cache = new NodeCache({ stdTTL: 600 });

function getCachedData(key) {
    const cached = cache.get(key);
    if (cached) return cached;
    
    const data = expensiveOperation();
    cache.set(key, data);
    return data;
}

// 3. Use worker threads for CPU-intensive tasks
const { Worker } = require('worker_threads');
const worker = new Worker('./worker.js');
worker.postMessage({ data: 'process' });
```

### 122. What are the best practices for handling memory in Node.js?

**Answer:**
Best practices for memory management:

```javascript
// 1. Proper cleanup of event listeners
class EventEmitter {
    constructor() {
        this.listeners = new Map();
    }

    addListener(event, callback) {
        if (!this.listeners.has(event)) {
            this.listeners.set(event, new Set());
        }
        this.listeners.get(event).add(callback);
    }

    removeListener(event, callback) {
        if (this.listeners.has(event)) {
            this.listeners.get(event).delete(callback);
        }
    }
}

// 2. Using WeakMap for caching
const cache = new WeakMap();

function cacheObject(obj) {
    cache.set(obj, {
        timestamp: Date.now(),
        data: obj.data
    });
}

// 3. Proper stream handling
const stream = require('stream');
const pipeline = util.promisify(stream.pipeline);

async function processStream() {
    await pipeline(
        fs.createReadStream('input.txt'),
        new stream.Transform({
            transform(chunk, encoding, callback) {
                // Process chunk
                callback(null, chunk);
            }
        }),
        fs.createWriteStream('output.txt')
    );
}
```

### 123. How do you implement caching in Node.js applications?

**Answer:**
Different caching strategies in Node.js:

```javascript
// 1. In-memory caching
const NodeCache = require('node-cache');
const cache = new NodeCache({ stdTTL: 600 });

// 2. Redis caching
const Redis = require('ioredis');
const redis = new Redis();

// 3. Multi-level caching
class MultiLevelCache {
    constructor() {
        this.memoryCache = new NodeCache();
        this.redis = new Redis();
    }

    async get(key) {
        // Try memory cache first
        const memoryData = this.memoryCache.get(key);
        if (memoryData) return memoryData;

        // Try Redis cache
        const redisData = await this.redis.get(key);
        if (redisData) {
            this.memoryCache.set(key, redisData);
            return redisData;
        }

        // Get from database
        const data = await this.fetchFromDB(key);
        await this.redis.set(key, data);
        this.memoryCache.set(key, data);
        return data;
    }
}
```

### 124. What is the purpose of the Node.js profiler?

**Answer:**
The Node.js profiler helps identify performance bottlenecks:

```javascript
// Using the built-in profiler
const profiler = require('v8-profiler');

// Start profiling
profiler.startProfiling('MyProfile');

// Your code here
function expensiveOperation() {
    let result = 0;
    for (let i = 0; i < 1000000; i++) {
        result += i;
    }
    return result;
}

// Stop profiling and save
const profile = profiler.stopProfiling('MyProfile');
profile.export((error, result) => {
    fs.writeFileSync('profile.cpuprofile', result);
    profile.delete();
});

// Using the --prof flag
// node --prof app.js
```

### 125. How do you handle CPU-intensive tasks in Node.js?

**Answer:**
Using worker threads for CPU-intensive tasks:

```javascript
const { Worker, isMainThread, parentPort } = require('worker_threads');

if (isMainThread) {
    // Main thread
    const worker = new Worker(__filename);
    
    worker.on('message', (result) => {
        console.log('Result:', result);
    });
    
    worker.postMessage({ data: 'process' });
} else {
    // Worker thread
    parentPort.on('message', (message) => {
        const result = cpuIntensiveTask(message.data);
        parentPort.postMessage(result);
    });
}

function cpuIntensiveTask(data) {
    // CPU-intensive operations
    let result = 0;
    for (let i = 0; i < 1000000; i++) {
        result += i;
    }
    return result;
}
```

### 126. What is the purpose of the Node.js performance hooks?

**Answer:**
Performance hooks for measuring application performance:

```javascript
const { performance, PerformanceObserver } = require('perf_hooks');

// Create observer
const obs = new PerformanceObserver((list) => {
    const entries = list.getEntries();
    entries.forEach((entry) => {
        console.log(`${entry.name}: ${entry.duration}`);
    });
});
obs.observe({ entryTypes: ['measure'] });

// Measure performance
performance.mark('start');
// ... your code here ...
performance.mark('end');
performance.measure('My Operation', 'start', 'end');

// Measure async operations
async function measureAsync() {
    performance.mark('async-start');
    await someAsyncOperation();
    performance.mark('async-end');
    performance.measure('Async Operation', 'async-start', 'async-end');
}
```

### 127. How do you optimize database queries in Node.js?

**Answer:**
Database query optimization techniques:

```javascript
// 1. Using connection pooling
const mysql = require('mysql2/promise');

const pool = mysql.createPool({
    host: 'localhost',
    user: 'user',
    password: 'password',
    database: 'mydb',
    waitForConnections: true,
    connectionLimit: 10,
    queueLimit: 0
});

// 2. Query optimization
async function getOptimizedData() {
    const [rows] = await pool.query(`
        SELECT u.id, u.name, p.title
        FROM users u
        INNER JOIN posts p ON u.id = p.user_id
        WHERE u.active = ?
        LIMIT 100
    `, [true]);
    return rows;
}

// 3. Using prepared statements
const stmt = await pool.prepare(`
    INSERT INTO users (name, email) VALUES (?, ?)
`);
await stmt.execute(['John', 'john@example.com']);
```

### 128. What is the purpose of the Node.js debugger?

**Answer:**
Using the Node.js debugger for debugging:

```javascript
// Start debugger
// node --inspect app.js

// Debugging code
function debugExample() {
    debugger; // Breakpoint
    const x = 1;
    const y = 2;
    const z = x + y;
    console.log(z);
}

// Using console for debugging
console.log('Debug:', { x: 1, y: 2 });
console.trace('Stack trace');
console.time('Operation');
// ... code ...
console.timeEnd('Operation');
```

### 129. How do you handle long-running processes in Node.js?

**Answer:**
Managing long-running processes:

```javascript
// 1. Using worker threads
const { Worker } = require('worker_threads');

function runLongProcess() {
    const worker = new Worker('./worker.js');
    worker.on('message', (result) => {
        console.log('Process completed:', result);
    });
    worker.postMessage({ start: true });
}

// 2. Using child processes
const { spawn } = require('child_process');

function runExternalProcess() {
    const process = spawn('long-running-script.sh');
    
    process.stdout.on('data', (data) => {
        console.log(`Output: ${data}`);
    });
    
    process.stderr.on('data', (data) => {
        console.error(`Error: ${data}`);
    });
    
    process.on('close', (code) => {
        console.log(`Process exited with code ${code}`);
    });
}
```

### 130. What is the purpose of the Node.js inspector?

**Answer:**
Using the Node.js inspector for debugging:

```javascript
// Start inspector
// node --inspect app.js

// Debugging code
function debugWithInspector() {
    const obj = {
        name: 'John',
        age: 30,
        address: {
            city: 'New York',
            country: 'USA'
        }
    };

    // Set breakpoint in code
    debugger;

    // Complex operation
    const result = obj.address.city.toUpperCase();
    console.log(result);
}

// Using console for inspection
console.dir(obj, { depth: null, colors: true });
console.table([
    { name: 'John', age: 30 },
    { name: 'Jane', age: 25 }
]);
```

### 131. How do you implement secure authentication in Node.js?

**Answer:**
Secure authentication implementation:

```javascript
const express = require('express');
const jwt = require('jsonwebtoken');
const bcrypt = require('bcrypt');

// Authentication middleware
const auth = async (req, res, next) => {
    try {
        const token = req.header('Authorization').replace('Bearer ', '');
        const decoded = jwt.verify(token, process.env.JWT_SECRET);
        req.user = decoded;
        next();
    } catch (error) {
        res.status(401).send({ error: 'Please authenticate' });
    }
};

// Login route
app.post('/login', async (req, res) => {
    const { email, password } = req.body;
    const user = await User.findOne({ email });
    
    if (!user || !await bcrypt.compare(password, user.password)) {
        return res.status(401).send({ error: 'Invalid credentials' });
    }
    
    const token = jwt.sign({ id: user._id }, process.env.JWT_SECRET, {
        expiresIn: '24h'
    });
    
    res.send({ token });
});
```

### 132. What is the purpose of the Node.js crypto module?

**Answer:**
Using the crypto module for encryption and hashing:

```javascript
const crypto = require('crypto');

// Encryption
function encrypt(text, key) {
    const iv = crypto.randomBytes(16);
    const cipher = crypto.createCipheriv('aes-256-cbc', key, iv);
    let encrypted = cipher.update(text, 'utf8', 'hex');
    encrypted += cipher.final('hex');
    return { iv: iv.toString('hex'), encrypted };
}

// Decryption
function decrypt(encrypted, key, iv) {
    const decipher = crypto.createDecipheriv('aes-256-cbc', key, Buffer.from(iv, 'hex'));
    let decrypted = decipher.update(encrypted, 'hex', 'utf8');
    decrypted += decipher.final('utf8');
    return decrypted;
}

// Hashing
function hashPassword(password) {
    const salt = crypto.randomBytes(16).toString('hex');
    const hash = crypto.pbkdf2Sync(password, salt, 1000, 64, 'sha512').toString('hex');
    return { salt, hash };
}
```

### 133. How do you handle secure password storage in Node.js?

**Answer:**
Secure password storage using bcrypt:

```javascript
const bcrypt = require('bcrypt');

class User {
    async setPassword(password) {
        const saltRounds = 10;
        this.salt = await bcrypt.genSalt(saltRounds);
        this.password = await bcrypt.hash(password, this.salt);
    }

    async validatePassword(password) {
        return await bcrypt.compare(password, this.password);
    }
}

// Usage
const user = new User();
await user.setPassword('myPassword');
const isValid = await user.validatePassword('myPassword');
```

### 134. What is the purpose of the Node.js tls module?

**Answer:**
Using the TLS module for secure connections:

```javascript
const tls = require('tls');
const fs = require('fs');

const options = {
    key: fs.readFileSync('private-key.pem'),
    cert: fs.readFileSync('certificate.pem'),
    ca: [fs.readFileSync('ca-certificate.pem')]
};

const server = tls.createServer(options, (socket) => {
    console.log('Client connected');
    
    socket.on('data', (data) => {
        console.log('Received:', data.toString());
    });
    
    socket.on('end', () => {
        console.log('Client disconnected');
    });
});

server.listen(8000, () => {
    console.log('Server listening on port 8000');
});
```

### 135. How do you implement secure session management in Node.js?

**Answer:**
Secure session management using express-session:

```javascript
const session = require('express-session');
const RedisStore = require('connect-redis')(session);
const Redis = require('ioredis');

const redisClient = new Redis({
    host: 'redis',
    port: 6379
});

app.use(session({
    store: new RedisStore({ client: redisClient }),
    secret: process.env.SESSION_SECRET,
    resave: false,
    saveUninitialized: false,
    cookie: {
        secure: true,
        httpOnly: true,
        maxAge: 1000 * 60 * 60 * 24, // 24 hours
        sameSite: 'strict'
    }
}));
```

### 136. What is the purpose of the Node.js https module?

**Answer:**
Creating HTTPS servers:

```javascript
const https = require('https');
const fs = require('fs');

const options = {
    key: fs.readFileSync('private-key.pem'),
    cert: fs.readFileSync('certificate.pem')
};

const server = https.createServer(options, (req, res) => {
    res.writeHead(200);
    res.end('Hello Secure World!');
});

server.listen(443, () => {
    console.log('HTTPS server running on port 443');
});
```

### 137. How do you handle secure file uploads in Node.js?

**Answer:**
Secure file upload handling:

```javascript
const multer = require('multer');
const path = require('path');
const crypto = require('crypto');

const storage = multer.diskStorage({
    destination: (req, file, cb) => {
        cb(null, 'uploads/');
    },
    filename: (req, file, cb) => {
        const uniqueSuffix = crypto.randomBytes(16).toString('hex');
        cb(null, uniqueSuffix + path.extname(file.originalname));
    }
});

const upload = multer({
    storage: storage,
    limits: {
        fileSize: 5 * 1024 * 1024 // 5MB
    },
    fileFilter: (req, file, cb) => {
        const allowedTypes = ['image/jpeg', 'image/png', 'application/pdf'];
        if (allowedTypes.includes(file.mimetype)) {
            cb(null, true);
        } else {
            cb(new Error('Invalid file type'));
        }
    }
});

app.post('/upload', upload.single('file'), (req, res) => {
    res.send('File uploaded successfully');
});
```

### 138. What is the purpose of the Node.js net module?

**Answer:**
Creating TCP servers and clients:

```javascript
const net = require('net');

// TCP Server
const server = net.createServer((socket) => {
    console.log('Client connected');
    
    socket.on('data', (data) => {
        console.log('Received:', data.toString());
        socket.write('Echo: ' + data);
    });
    
    socket.on('end', () => {
        console.log('Client disconnected');
    });
});

server.listen(3000, () => {
    console.log('Server listening on port 3000');
});

// TCP Client
const client = new net.Socket();
client.connect(3000, 'localhost', () => {
    client.write('Hello Server!');
});

client.on('data', (data) => {
    console.log('Received:', data.toString());
    client.destroy();
});
```

### 139. How do you implement secure WebSocket connections in Node.js?

**Answer:**
Secure WebSocket implementation:

```javascript
const WebSocket = require('ws');
const https = require('https');
const fs = require('fs');

const server = https.createServer({
    cert: fs.readFileSync('certificate.pem'),
    key: fs.readFileSync('private-key.pem')
});

const wss = new WebSocket.Server({ server });

wss.on('connection', (ws, req) => {
    // Verify client
    if (!isValidClient(req)) {
        ws.close();
        return;
    }

    ws.on('message', (message) => {
        // Validate message
        if (!isValidMessage(message)) {
            ws.send('Invalid message');
            return;
        }

        // Process message
        processMessage(message);
    });

    ws.on('close', () => {
        console.log('Client disconnected');
    });
});

server.listen(8443);
```

### 140. What is the purpose of the Node.js dgram module?

**Answer:**
UDP server and client implementation:

```javascript
const dgram = require('dgram');

// UDP Server
const server = dgram.createSocket('udp4');

server.on('error', (err) => {
    console.error(`Server error:\n${err.stack}`);
    server.close();
});

server.on('message', (msg, rinfo) => {
    console.log(`Server got: ${msg} from ${rinfo.address}:${rinfo.port}`);
});

server.on('listening', () => {
    const address = server.address();
    console.log(`Server listening ${address.address}:${address.port}`);
});

server.bind(41234);

// UDP Client
const client = dgram.createSocket('udp4');
const message = Buffer.from('Hello Server!');

client.send(message, 41234, 'localhost', (err) => {
    if (err) {
        console.error('Error sending message:', err);
    }
    client.close();
});
```

### 141. How do you write unit tests in Node.js?

**Answer:**
Unit testing with Jest:

```javascript
// math.js
function add(a, b) {
    return a + b;
}

function subtract(a, b) {
    return a - b;
}

module.exports = { add, subtract };

// math.test.js
const { add, subtract } = require('./math');

describe('Math functions', () => {
    test('adds 1 + 2 to equal 3', () => {
        expect(add(1, 2)).toBe(3);
    });

    test('subtracts 5 - 3 to equal 2', () => {
        expect(subtract(5, 3)).toBe(2);
    });
});
```

### 142. What is the purpose of the Node.js assert module?

**Answer:**
Using the assert module for testing:

```javascript
const assert = require('assert');

// Basic assertions
assert.strictEqual(1 + 1, 2);
assert.deepStrictEqual({ a: 1 }, { a: 1 });

// Custom error messages
assert.strictEqual(
    typeof 'hello',
    'string',
    'Expected type to be string'
);

// Testing async code
async function testAsync() {
    const result = await someAsyncOperation();
    assert.strictEqual(result, expectedValue);
}
```

### 143. How do you implement integration tests in Node.js?

**Answer:**
Integration testing with Jest and Supertest:

```javascript
const request = require('supertest');
const app = require('./app');

describe('API Integration Tests', () => {
    test('GET /api/users', async () => {
        const response = await request(app)
            .get('/api/users')
            .expect('Content-Type', /json/)
            .expect(200);

        expect(response.body).toHaveLength(2);
    });

    test('POST /api/users', async () => {
        const newUser = {
            name: 'John',
            email: 'john@example.com'
        };

        const response = await request(app)
            .post('/api/users')
            .send(newUser)
            .expect(201);

        expect(response.body).toHaveProperty('id');
    });
});
```

### 144. What is the purpose of the Node.js test module?

**Answer:**
Using the built-in test module:

```javascript
const test = require('test');

test('Basic test', (t) => {
    t.plan(2);
    t.equal(1 + 1, 2);
    t.deepEqual({ a: 1 }, { a: 1 });
});

test('Async test', async (t) => {
    t.plan(1);
    const result = await someAsyncOperation();
    t.equal(result, expectedValue);
});
```

### 145. How do you implement end-to-end tests in Node.js?

**Answer:**
End-to-end testing with Puppeteer:

```javascript
const puppeteer = require('puppeteer');

describe('E2E Tests', () => {
    let browser;
    let page;

    beforeAll(async () => {
        browser = await puppeteer.launch();
        page = await browser.newPage();
    });

    afterAll(async () => {
        await browser.close();
    });

    test('User can login', async () => {
        await page.goto('http://localhost:3000/login');
        await page.type('#email', 'user@example.com');
        await page.type('#password', 'password');
        await page.click('#login-button');
        await page.waitForNavigation();
        expect(page.url()).toBe('http://localhost:3000/dashboard');
    });
});
```

### 146. What is the purpose of the Node.js vm module?

**Answer:**
Using the VM module for sandboxed code execution:

```javascript
const vm = require('vm');

// Running code in a sandbox
const context = {
    console: console,
    x: 10
};

const script = new vm.Script(`
    console.log(x);
    x = 20;
    console.log(x);
`);

const contextifiedSandbox = vm.createContext(context);
script.runInContext(contextifiedSandbox);

// Running code with timeout
const timeoutScript = new vm.Script('while(true) {}');
try {
    timeoutScript.runInNewContext({}, { timeout: 1000 });
} catch (error) {
    console.error('Script timed out');
}
```

### 147. How do you implement performance tests in Node.js?

**Answer:**
Performance testing with autocannon:

```javascript
const autocannon = require('autocannon');

async function runPerformanceTest() {
    const result = await autocannon({
        url: 'http://localhost:3000/api',
        connections: 100,
        duration: 10,
        requests: [
            {
                method: 'GET',
                path: '/users'
            },
            {
                method: 'POST',
                path: '/users',
                body: JSON.stringify({
                    name: 'John',
                    email: 'john@example.com'
                })
            }
        ]
    });

    console.log(result);
}

runPerformanceTest();
```

### 148. What is the purpose of the Node.js repl module?

**Answer:**
Using the REPL module for interactive Node.js sessions:

```javascript
const repl = require('repl');

// Custom REPL server
const replServer = repl.start({
    prompt: 'Node.js > ',
    useColors: true
});

// Add custom commands
replServer.defineCommand('hello', {
    help: 'Say hello',
    action(name) {
        this.clearBufferedCommand();
        console.log(`Hello, ${name}!`);
        this.displayPrompt();
    }
});

// Add custom context
replServer.context.db = {
    query: (sql) => {
        console.log(`Executing: ${sql}`);
    }
};
```

### 149. How do you implement security tests in Node.js?

**Answer:**
Security testing with OWASP ZAP and Jest:

```javascript
const { ZapClient } = require('zaproxy');

describe('Security Tests', () => {
    let zap;

    beforeAll(async () => {
        zap = new ZapClient({
            apiKey: process.env.ZAP_API_KEY,
            proxy: 'http://localhost:8080'
        });
    });

    test('SQL Injection Prevention', async () => {
        const response = await request(app)
            .get('/api/users')
            .query({ id: "1' OR '1'='1" })
            .expect(400);
    });

    test('XSS Prevention', async () => {
        const response = await request(app)
            .post('/api/comments')
            .send({
                content: '<script>alert("xss")</script>'
            })
            .expect(400);
    });
});
```

### 150. What is the purpose of the Node.js readline module?

**Answer:**
Using the readline module for interactive command-line interfaces:

```javascript
const readline = require('readline');

const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
});

// Simple question-answer
rl.question('What is your name? ', (answer) => {
    console.log(`Hello, ${answer}!`);
    rl.close();
});

// Multiple questions
async function askQuestions() {
    const name = await new Promise(resolve => {
        rl.question('What is your name? ', resolve);
    });

    const age = await new Promise(resolve => {
        rl.question('What is your age? ', resolve);
    });

    console.log(`Hello ${name}, you are ${age} years old`);
    rl.close();
}

askQuestions();
