# Node.js Interview Questions and Answers (51-75)

## Database Integration

### 51. How do you connect to MongoDB using Node.js?

**Answer:**
MongoDB can be connected using the official MongoDB driver or Mongoose ODM. Here's how to do it with both approaches:

**Example using MongoDB driver:**
```javascript
const { MongoClient } = require('mongodb');

async function connectToMongo() {
    try {
        const client = new MongoClient('mongodb://localhost:27017');
        await client.connect();
        console.log('Connected to MongoDB');
        return client.db('mydatabase');
    } catch (error) {
        console.error('Connection error:', error);
        throw error;
    }
}

// Usage
connectToMongo()
    .then(db => {
        // Use db object for operations
    })
    .catch(console.error);
```

### 52. What is Mongoose and how do you use it?

**Answer:**
Mongoose is an Object Data Modeling (ODM) library for MongoDB and Node.js. It provides:
- Schema definition
- Data validation
- Middleware
- Type casting
- Query building

**Example:**
```javascript
const mongoose = require('mongoose');

// Define Schema
const userSchema = new mongoose.Schema({
    name: { type: String, required: true },
    email: { type: String, required: true, unique: true },
    age: { type: Number, min: 0 }
});

// Create Model
const User = mongoose.model('User', userSchema);

// Connect to MongoDB
mongoose.connect('mongodb://localhost:27017/mydatabase');

// Create and save document
async function createUser() {
    try {
        const user = new User({
            name: 'John Doe',
            email: 'john@example.com',
            age: 30
        });
        await user.save();
        console.log('User saved successfully');
    } catch (error) {
        console.error('Error:', error);
    }
}
```

### 53. How do you perform CRUD operations in MongoDB?

**Answer:**
CRUD operations in MongoDB can be performed using either the MongoDB driver or Mongoose:

**Example using Mongoose:**
```javascript
const User = require('./models/user');

// Create
async function createUser(userData) {
    const user = new User(userData);
    return await user.save();
}

// Read
async function getUsers() {
    return await User.find();
}

async function getUserById(id) {
    return await User.findById(id);
}

// Update
async function updateUser(id, updateData) {
    return await User.findByIdAndUpdate(id, updateData, { new: true });
}

// Delete
async function deleteUser(id) {
    return await User.findByIdAndDelete(id);
}
```

### 54. What is the difference between SQL and NoSQL databases?

**Answer:**
Key differences between SQL and NoSQL databases:

SQL (e.g., MySQL, PostgreSQL):
- Structured data with predefined schema
- ACID compliance
- Vertical scaling
- Better for complex queries
- Strong data consistency

NoSQL (e.g., MongoDB, Redis):
- Flexible schema
- Horizontal scaling
- Better for large datasets
- Eventual consistency
- Better performance for simple queries

**Example:**
```javascript
// SQL (using MySQL)
const mysql = require('mysql2/promise');

async function sqlExample() {
    const connection = await mysql.createConnection({
        host: 'localhost',
        user: 'root',
        database: 'mydb'
    });

    // Structured query with joins
    const [rows] = await connection.execute(`
        SELECT users.name, orders.product
        FROM users
        JOIN orders ON users.id = orders.user_id
    `);
}

// NoSQL (using MongoDB)
const mongoose = require('mongoose');

async function nosqlExample() {
    // Flexible document structure
    const user = {
        name: 'John',
        orders: [
            { product: 'Laptop', price: 1000 },
            { product: 'Phone', price: 500 }
        ]
    };
    await User.create(user);
}
```

### 55. How do you handle database transactions in Node.js?

**Answer:**
Database transactions ensure data integrity across multiple operations. Here's how to handle them:

**Example using MongoDB:**
```javascript
const mongoose = require('mongoose');

async function transferMoney(fromAccountId, toAccountId, amount) {
    const session = await mongoose.startSession();
    session.startTransaction();

    try {
        // Debit from account
        await Account.findByIdAndUpdate(
            fromAccountId,
            { $inc: { balance: -amount } },
            { session }
        );

        // Credit to account
        await Account.findByIdAndUpdate(
            toAccountId,
            { $inc: { balance: amount } },
            { session }
        );

        await session.commitTransaction();
        console.log('Transaction successful');
    } catch (error) {
        await session.abortTransaction();
        console.error('Transaction failed:', error);
        throw error;
    } finally {
        session.endSession();
    }
}
```

### 56. What is connection pooling and how do you implement it?

**Answer:**
Connection pooling maintains a pool of database connections to improve performance. Here's how to implement it:

**Example using MongoDB:**
```javascript
const mongoose = require('mongoose');

const options = {
    poolSize: 10,
    serverSelectionTimeoutMS: 5000,
    socketTimeoutMS: 45000,
};

mongoose.connect('mongodb://localhost:27017/mydatabase', options);

// Monitor connection events
mongoose.connection.on('connected', () => {
    console.log('Mongoose connected');
});

mongoose.connection.on('error', (err) => {
    console.error('Mongoose connection error:', err);
});

mongoose.connection.on('disconnected', () => {
    console.log('Mongoose disconnected');
});
```

### 57. How do you implement caching in Node.js?

**Answer:**
Caching can be implemented using:
- In-memory caching
- Redis
- Memcached
- Browser caching

**Example using Redis:**
```javascript
const redis = require('redis');
const client = redis.createClient();

async function getCachedData(key) {
    try {
        // Check cache first
        const cachedData = await client.get(key);
        if (cachedData) {
            return JSON.parse(cachedData);
        }

        // If not in cache, get from database
        const data = await fetchFromDatabase();
        
        // Store in cache
        await client.set(key, JSON.stringify(data), 'EX', 3600); // Expire in 1 hour
        
        return data;
    } catch (error) {
        console.error('Cache error:', error);
        throw error;
    }
}
```

### 58. What is Redis and how do you use it with Node.js?

**Answer:**
Redis is an in-memory data structure store used for:
- Caching
- Session storage
- Message broker
- Real-time analytics

**Example:**
```javascript
const redis = require('redis');
const client = redis.createClient();

// Basic operations
async function redisExample() {
    // Set value
    await client.set('key', 'value');
    
    // Get value
    const value = await client.get('key');
    
    // Set with expiration
    await client.set('temp', 'data', 'EX', 60);
    
    // List operations
    await client.lPush('list', 'item1');
    await client.lPush('list', 'item2');
    
    // Hash operations
    await client.hSet('user:1', {
        name: 'John',
        email: 'john@example.com'
    });
}
```

### 59. How do you handle database migrations?

**Answer:**
Database migrations can be handled using:
- Mongoose migrations
- Custom migration scripts
- Migration libraries

**Example using custom migration:**
```javascript
const mongoose = require('mongoose');

async function migrateDatabase() {
    try {
        // Connect to database
        await mongoose.connect('mongodb://localhost:27017/mydatabase');

        // Add new field to all documents
        await User.updateMany(
            { age: { $exists: false } },
            { $set: { age: 0 } }
        );

        // Rename field
        await User.updateMany(
            { firstName: { $exists: true } },
            [
                { $set: { name: '$firstName' } },
                { $unset: 'firstName' }
            ]
        );

        console.log('Migration completed successfully');
    } catch (error) {
        console.error('Migration failed:', error);
        throw error;
    }
}
```

### 60. What is the purpose of database indexing?

**Answer:**
Database indexing improves query performance by:
- Creating ordered references to data
- Speeding up data retrieval
- Optimizing search operations

**Example using Mongoose:**
```javascript
const mongoose = require('mongoose');

const userSchema = new mongoose.Schema({
    email: { 
        type: String, 
        required: true,
        index: true, // Single field index
        unique: true
    },
    name: String,
    age: Number
});

// Compound index
userSchema.index({ name: 1, age: -1 });

// Text index for search
userSchema.index({ name: 'text', email: 'text' });

const User = mongoose.model('User', userSchema);
```

## Testing and Debugging

### 61. What testing frameworks are commonly used with Node.js?

**Answer:**
Common testing frameworks include:
- Jest
- Mocha
- Chai
- Supertest
- Sinon

**Example using Jest:**
```javascript
// user.test.js
const User = require('./user');

describe('User', () => {
    test('should create user with valid data', () => {
        const user = new User({
            name: 'John',
            email: 'john@example.com'
        });
        expect(user.name).toBe('John');
        expect(user.email).toBe('john@example.com');
    });

    test('should validate email format', () => {
        expect(() => {
            new User({
                name: 'John',
                email: 'invalid-email'
            });
        }).toThrow('Invalid email format');
    });
});
```

### 62. How do you write unit tests in Node.js?

**Answer:**
Unit tests focus on testing individual components in isolation:

**Example using Jest:**
```javascript
// math.js
function add(a, b) {
    return a + b;
}

function subtract(a, b) {
    return a - b;
}

module.exports = { add, subtract };

// math.test.js
const { add, subtract } = require('./math');

describe('Math functions', () => {
    test('adds 1 + 2 to equal 3', () => {
        expect(add(1, 2)).toBe(3);
    });

    test('subtracts 5 - 3 to equal 2', () => {
        expect(subtract(5, 3)).toBe(2);
    });

    test('handles negative numbers', () => {
        expect(add(-1, -2)).toBe(-3);
        expect(subtract(-5, -3)).toBe(-2);
    });
});
```

### 63. What is the difference between unit testing and integration testing?

**Answer:**
Unit testing:
- Tests individual components
- Isolates dependencies
- Fast execution
- Uses mocks/stubs

Integration testing:
- Tests component interactions
- Uses real dependencies
- Slower execution
- Tests workflows

**Example:**
```javascript
// Unit test
describe('UserService', () => {
    let userService;
    let mockUserRepository;

    beforeEach(() => {
        mockUserRepository = {
            findById: jest.fn()
        };
        userService = new UserService(mockUserRepository);
    });

    test('should get user by id', async () => {
        mockUserRepository.findById.mockResolvedValue({ id: 1, name: 'John' });
        const user = await userService.getUser(1);
        expect(user.name).toBe('John');
    });
});

// Integration test
describe('User API', () => {
    test('should create and retrieve user', async () => {
        // Create user
        const response = await request(app)
            .post('/api/users')
            .send({ name: 'John', email: 'john@example.com' });
        expect(response.status).toBe(201);

        // Get user
        const user = await request(app)
            .get(`/api/users/${response.body.id}`);
        expect(user.body.name).toBe('John');
    });
});
```

### 64. How do you debug Node.js applications?

**Answer:**
Debugging can be done using:
- console methods
- Node.js debugger
- IDE debuggers
- Logging libraries

**Example:**
```javascript
// Using console methods
console.log('Debug info:', { key: 'value' });
console.error('Error occurred:', error);
console.time('operation');
// ... code ...
console.timeEnd('operation');

// Using debugger
function complexOperation() {
    debugger; // Breakpoint
    // ... code ...
}

// Using logging library (Winston)
const winston = require('winston');
const logger = winston.createLogger({
    level: 'debug',
    format: winston.format.json(),
    transports: [
        new winston.transports.File({ filename: 'error.log', level: 'error' }),
        new winston.transports.File({ filename: 'combined.log' })
    ]
});

logger.info('Info message');
logger.error('Error message', { error: err });
```

### 65. What is the purpose of the debugger statement?

**Answer:**
The debugger statement creates a breakpoint in the code where execution will pause when debugging is enabled.

**Example:**
```javascript
function processData(data) {
    debugger; // Execution will pause here when debugging
    const result = data.map(item => {
        debugger; // Another breakpoint
        return item * 2;
    });
    return result;
}

// Using with Chrome DevTools
// 1. Start Node with --inspect flag
// 2. Open chrome://inspect
// 3. Click on "Open dedicated DevTools for Node"
```

### 66. How do you use console.log() effectively for debugging?

**Answer:**
Effective console.log usage includes:
- Structured logging
- Different log levels
- Object inspection
- Performance measurement

**Example:**
```javascript
// Basic logging
console.log('User logged in:', username);

// Object inspection
console.log('User object:', {
    name: user.name,
    email: user.email,
    permissions: user.permissions
});

// Table format
console.table([
    { id: 1, name: 'John' },
    { id: 2, name: 'Jane' }
]);

// Performance measurement
console.time('database-query');
await db.query();
console.timeEnd('database-query');

// Stack trace
console.trace('Function called from:');

// Grouping logs
console.group('User Operations');
console.log('Creating user');
console.log('Sending welcome email');
console.log('Updating statistics');
console.groupEnd();
```

### 67. What is the difference between assert and expect in testing?

**Answer:**
- `assert`: Node.js built-in assertion library
- `expect`: Part of testing libraries like Jest/Chai, provides more readable syntax

**Example:**
```javascript
// Using assert
const assert = require('assert');

function testWithAssert() {
    const result = add(2, 3);
    assert.strictEqual(result, 5);
    assert.deepStrictEqual({ a: 1 }, { a: 1 });
}

// Using expect (Jest)
function testWithExpect() {
    const result = add(2, 3);
    expect(result).toBe(5);
    expect({ a: 1 }).toEqual({ a: 1 });
    expect(result).toBeGreaterThan(4);
    expect(result).toBeLessThan(6);
}
```

### 68. How do you mock dependencies in tests?

**Answer:**
Dependencies can be mocked using:
- Jest mock functions
- Sinon stubs/spies
- Manual mocks

**Example using Jest:**
```javascript
// userService.js
class UserService {
    constructor(userRepository) {
        this.userRepository = userRepository;
    }

    async getUser(id) {
        return await this.userRepository.findById(id);
    }
}

// userService.test.js
jest.mock('./userRepository');

describe('UserService', () => {
    let userService;
    let mockUserRepository;

    beforeEach(() => {
        mockUserRepository = {
            findById: jest.fn()
        };
        userService = new UserService(mockUserRepository);
    });

    test('should get user by id', async () => {
        const mockUser = { id: 1, name: 'John' };
        mockUserRepository.findById.mockResolvedValue(mockUser);

        const user = await userService.getUser(1);
        expect(user).toEqual(mockUser);
        expect(mockUserRepository.findById).toHaveBeenCalledWith(1);
    });
});
```

### 69. What is test coverage and how do you measure it?

**Answer:**
Test coverage measures how much of your code is tested. It can be measured using:
- Istanbul/nyc
- Jest coverage
- Custom coverage tools

**Example using Jest:**
```javascript
// jest.config.js
module.exports = {
    collectCoverage: true,
    coverageThreshold: {
        global: {
            branches: 80,
            functions: 80,
            lines: 80,
            statements: 80
        }
    }
};

// Example test with coverage
describe('Math operations', () => {
    test('add function', () => {
        expect(add(2, 3)).toBe(5);
    });

    test('subtract function', () => {
        expect(subtract(5, 3)).toBe(2);
    });
});
```

### 70. How do you handle asynchronous testing?

**Answer:**
Asynchronous testing can be handled using:
- async/await
- Promises
- Callbacks
- Jest's done callback

**Example:**
```javascript
// Using async/await
describe('Async operations', () => {
    test('should fetch user data', async () => {
        const user = await fetchUser(1);
        expect(user.name).toBe('John');
    });

    test('should handle errors', async () => {
        await expect(fetchUser(-1)).rejects.toThrow('User not found');
    });
});

// Using done callback
test('should complete async operation', done => {
    fetchUser(1, (err, user) => {
        expect(err).toBeNull();
        expect(user.name).toBe('John');
        done();
    });
});

// Using promises
test('should resolve promise', () => {
    return fetchUser(1).then(user => {
        expect(user.name).toBe('John');
    });
});
```

## Security

### 71. What are the common security vulnerabilities in Node.js applications?

**Answer:**
Common vulnerabilities include:
- SQL Injection
- XSS (Cross-Site Scripting)
- CSRF (Cross-Site Request Forgery)
- Insecure Dependencies
- Sensitive Data Exposure

**Example of preventing SQL injection:**
```javascript
// Bad: Vulnerable to SQL injection
const query = `SELECT * FROM users WHERE username = '${username}'`;

// Good: Using parameterized queries
const query = 'SELECT * FROM users WHERE username = ?';
const result = await db.query(query, [username]);

// Good: Using ORM
const user = await User.findOne({ username });
```

### 72. How do you prevent SQL injection?

**Answer:**
SQL injection can be prevented by:
- Using parameterized queries
- Using ORMs
- Input validation
- Escaping user input

**Example:**
```javascript
const mysql = require('mysql2/promise');

async function getUser(username) {
    const connection = await mysql.createConnection({
        host: 'localhost',
        user: 'root',
        database: 'mydb'
    });

    // Bad: Vulnerable to SQL injection
    // const query = `SELECT * FROM users WHERE username = '${username}'`;

    // Good: Using parameterized queries
    const query = 'SELECT * FROM users WHERE username = ?';
    const [rows] = await connection.execute(query, [username]);
    return rows[0];
}

// Using Mongoose (ORM)
const User = require('./models/user');

async function getUser(username) {
    return await User.findOne({ username });
}
```

### 73. What is XSS and how do you prevent it?

**Answer:**
XSS (Cross-Site Scripting) is a vulnerability where attackers inject malicious scripts. Prevention methods:
- Input sanitization
- Output encoding
- Content Security Policy
- Using security headers

**Example:**
```javascript
const express = require('express');
const helmet = require('helmet');
const xss = require('xss');
const app = express();

// Set security headers
app.use(helmet());

// Sanitize input
app.post('/comment', (req, res) => {
    const sanitizedComment = xss(req.body.comment);
    // Store sanitized comment
});

// Encode output
app.get('/user/:id', (req, res) => {
    const user = getUser(req.params.id);
    res.send(`
        <div>
            <h1>${encodeHTML(user.name)}</h1>
            <p>${encodeHTML(user.bio)}</p>
        </div>
    `);
});

function encodeHTML(str) {
    return str
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#039;');
}
```

### 74. How do you implement rate limiting?

**Answer:**
Rate limiting can be implemented using:
- Express-rate-limit
- Redis-based rate limiting
- Custom middleware

**Example:**
```javascript
const express = require('express');
const rateLimit = require('express-rate-limit');
const RedisStore = require('rate-limit-redis');
const redis = require('redis');

const app = express();

// Basic rate limiting
const limiter = rateLimit({
    windowMs: 15 * 60 * 1000, // 15 minutes
    max: 100 // limit each IP to 100 requests per windowMs
});

// Redis-based rate limiting
const redisClient = redis.createClient();
const redisLimiter = rateLimit({
    store: new RedisStore({
        client: redisClient,
        prefix: 'rate-limit:'
    }),
    windowMs: 15 * 60 * 1000,
    max: 100
});

// Apply to all requests
app.use(limiter);

// Apply to specific route
app.use('/api/', redisLimiter);
```

### 75. What is CSRF and how do you prevent it?

**Answer:**
CSRF (Cross-Site Request Forgery) is an attack where malicious sites make requests to your site. Prevention methods:
- CSRF tokens
- SameSite cookies
- Custom headers
- Double submit cookies

**Example:**
```javascript
const express = require('express');
const csrf = require('csurf');
const cookieParser = require('cookie-parser');
const app = express();

// Setup CSRF protection
app.use(cookieParser());
app.use(csrf({ cookie: true }));

// Add CSRF token to all responses
app.use((req, res, next) => {
    res.cookie('XSRF-TOKEN', req.csrfToken());
    next();
});

// Protected route
app.post('/api/transfer', (req, res) => {
    // CSRF token is automatically validated
    // Process the transfer
});

// Error handling
app.use((err, req, res, next) => {
    if (err.code === 'EBADCSRFTOKEN') {
        res.status(403).send('Invalid CSRF token');
    } else {
        next(err);
    }
});
``` 